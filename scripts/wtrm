# wtrm: safely remove a Git worktree (with fzf picker)
# Usage:
#   wtrm                              # pick interactively
#   wtrm -d /path/to/worktree         # remove by path
#   wtrm -b feature/xyz               # remove the worktree hosting this branch
#   wtrm --rm-detached [--yes]        # bulk remove detached worktrees (confirm unless --yes)
# Options:
#   -d, --dir <path>          Worktree directory to remove
#   -b, --branch <name>       Branch whose worktree to remove (if multiple, will prompt)
#   --delete-branch           Also delete the *local* branch if fully merged into base
#   --base <ref>              Base to check mergedness (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
#   --force                   Force removal even if dirty or ahead of upstream
#   --no-fzf                  Don‚Äôt use fzf; prompt fallback if needed
#   --prune-only              Just run 'git worktree prune' and exit
#   --rm-detached             Remove all detached worktrees (bulk)
#   --yes                     Non-interactive confirm (with --rm-detached)
#   -h, --help                Show help
# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WTRM__SCRIPT_FILE WTRM__SCRIPT_DIR WTRM__COMMON_LIB
WTRM__SCRIPT_FILE=${(%):-%N}
if [[ -n $WTRM__SCRIPT_FILE && -f $WTRM__SCRIPT_FILE ]]; then
  WTRM__SCRIPT_DIR="${WTRM__SCRIPT_FILE:A:h}"
else
  WTRM__SCRIPT_DIR="${0:A:h}"
fi
WTRM__COMMON_LIB="${WTRM__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WTRM__COMMON_LIB" ]] && source "$WTRM__COMMON_LIB" || true

wtrm() {
  emulate -L zsh
  setopt local_options pipefail no_xtrace

  # helpers are sourced at load time
  
  # Enable error recovery features
  if typeset -f wt_recovery_enabled >/dev/null 2>&1 && wt_recovery_enabled; then
    wt_transaction_begin
    trap 'wt_transaction_rollback 2>/dev/null || true' EXIT INT TERM
  fi

  local target_dir target_branch delete_branch=0 force=0 base_ref="" no_fzf=0 prune_only=0
  local rm_detached=0 assume_yes=0 jobs_opt=""
  local FZF_MISSING=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--dir)        target_dir="$2"; shift 2;;
      -b|--branch)     target_branch="$2"; shift 2;;
      --delete-branch) delete_branch=1; shift;;
      --base)          base_ref="$2"; shift 2;;
      --force)         force=1; shift;;
      --no-fzf)        no_fzf=1; shift;;
      --prune-only)    prune_only=1; shift;;
      --rm-detached)   rm_detached=1; shift;;
      --jobs)          jobs_opt="$2"; shift 2;;
      --yes)           assume_yes=1; shift;;
      -h|--help)
        cat <<'USAGE'
wtrm: safely remove a Git worktree.

Examples:
  wtrm
  wtrm -d ../repo-feature-x
  wtrm -b feature/x --delete-branch
  wtrm --rm-detached --yes

Options:
  -d, --dir <path>       Worktree directory to remove
  -b, --branch <name>    Branch whose worktree to remove (prompts if multiple)
  --delete-branch        Delete the local branch after removal if fully merged
  --base <ref>           Base ref for merged check (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
  --force                Force removal even if dirty or ahead of upstream
  --no-fzf               Don‚Äôt use fzf for selection
  --prune-only           Only run 'git worktree prune' and exit
  --rm-detached          Remove all detached worktrees
  --jobs <N>             Max parallel removals when using --rm-detached (smart default)
  --yes                  Skip confirmation (used with --rm-detached)
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  if ! git rev-parse --git-dir &>/dev/null; then
    echo "‚ùå Not a git repo"
    if typeset -f wt_show_hints >/dev/null 2>&1; then
      echo ""
      echo "üí° Hint: Run this command from inside a git repository"
    fi
    return 1
  fi

  # Keep remotes up-to-date (optional, consistent with wtnew)
  echo "üîÑ  Fetching remotes‚Ä¶"
  if ! git fetch --all --prune --tags --quiet 2>/dev/null; then
    # Network failure - continue with cached refs
    if typeset -f wt_diagnose_error >/dev/null 2>&1; then
      echo "‚ö†Ô∏è  Fetch failed, continuing with cached refs..."
    else
      true  # Continue silently
    fi
  fi

  if (( prune_only )); then
    echo "üßπ Pruning stale worktrees‚Ä¶"
    git worktree prune
    return $?
  fi

  command -v fzf >/dev/null || FZF_MISSING=1

  # --- Build worktree table via shared helper: path|branch|head ---
  local porcelain wt_table
  porcelain="$(git worktree list --porcelain 2>/dev/null)"
  wt_table="$(wt_parse_worktrees_table "$porcelain")"

  [[ -z "$wt_table" ]] && { echo "‚ùå No worktrees found."; return 1; }

  # --- Bulk removal of detached worktrees ---
  if (( rm_detached )); then
    local det_list det_count
    det_list="$(printf "%s\n" "$wt_table" | awk -F'|' '$2=="(detached)" {printf "%s %s\n", $1, $3}')"
    det_count="$(printf "%s\n" "$det_list" | sed '/^\s*$/d' | wc -l | tr -d ' ')"
    if [[ -z "$det_list" ]]; then
      echo "‚ÑπÔ∏è  No detached worktrees found."
      return 0
    fi

    echo "üß≠ Detached worktrees to remove ($det_count):"
    printf "%s\n" "$det_list" | awk '{printf "  - %s (HEAD %s)\n", $1, substr($2,1,7)}'

    if (( !assume_yes )); then
      printf "Proceed? [y/N]: "
      local ans; read -r ans
      [[ "$ans" == "y" || "$ans" == "Y" ]] || { echo "‚ùé Cancelled."; return 1; }
    fi

    local ok=0 skipped=0 err=0
    local targets; targets="$(printf "%s\n" "$det_list" | sed '/^\s*$/d')"
    local total; total="$(printf "%s\n" "$targets" | wc -l | tr -d ' ')"
    local jobs; jobs="$(wt_detect_jobs_cap "${jobs_opt:-${WTRM_JOBS:-}}" "$total")"

    if (( jobs <= 1 )); then
      local wt_path sha dirty
      while read -r wt_path sha; do
        [[ -z "$wt_path" ]] && continue
        dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
        if [[ -n "$dirty" && $force -eq 0 ]]; then
          echo "‚è≠Ô∏è  Skipping dirty detached worktree: $wt_path (use --force to remove)"
          ((skipped++)); continue
        fi
        if git worktree remove ${force:+--force} "$wt_path"; then
          echo "üóë  Removed: $wt_path"; ((ok++))
        else
          echo "‚ùå Failed to remove: $wt_path"; ((err++))
        fi
      done <<<"$targets"
    else
      # Prefer xargs parallelism with deterministic order
      if wt_xargs_supports_parallel; then
        # Prepare a NUL-delimited input with index|path|sha
        local input_file; input_file="$(mktemp)"
        local idx=0
        while read -r wt_path sha; do
          idx=$((idx+1))
          printf "%s\0%s\0%s\0" "$idx" "$wt_path" "$sha" >> "$input_file"
        done <<<"$targets"
        # Use sh -c worker that consumes 3 args and respects F_FORCE env; emit tab-delimited IDX,TYPE,PATH
        local results_file; results_file="$(mktemp)"
        F_FORCE=$force xargs -0 -n 3 -P "$jobs" sh -c '
          idx="$1"; p="$2"; s="$3";
          if [ -z "$p" ]; then printf "%s\tERR\tempty\n" "$idx"; exit 0; fi
          m_dirty=$(git -C "$p" status --porcelain --untracked-files=all 2>/dev/null || true)
          if [ -n "$m_dirty" ] && [ "${F_FORCE:-0}" -eq 0 ]; then
            printf "%s\tSKIP\t%s\n" "$idx" "$p"; exit 0
          fi
          if git worktree remove $( [ "${F_FORCE:-0}" -ne 0 ] && printf %s -- --force ) "$p" >/dev/null 2>&1; then
            printf "%s\tOK\t%s\n" "$idx" "$p"
          else
            printf "%s\tERR\t%s\n" "$idx" "$p"
          fi
        ' _ < "$input_file" | sort -n -k1,1 > "$results_file"
        while IFS=$'\t' read -r i kind path_rest; do
          case "$kind" in
            (OK)   echo "üóë  Removed: ${path_rest}"; ((ok++));;
            (SKIP) echo "‚è≠Ô∏è  Skipping dirty detached worktree: ${path_rest} (use --force to remove)"; ((skipped++));;
            (ERR)  echo "‚ùå Failed to remove: ${path_rest}"; ((err++));;
          esac
        done < "$results_file"
        rm -f "$results_file" "$input_file"
      else
        # Fallback: mkfifo/semaphore if available; else serial
        if command -v mkfifo >/dev/null 2>&1 && command -v seq >/dev/null 2>&1; then
          local fifo; fifo=$(mktemp -u)
          mkfifo "$fifo" || { echo "‚ùå mkfifo failed"; jobs=1; }
          if (( jobs > 1 )); then
            exec 9<>"$fifo"; rm -f "$fifo"
            local i; for i in $(seq 1 $jobs); do echo >&9; done
            local results; results="$(mktemp)"
            while read -r wt_path sha; do
              read -u 9
              {
                if [[ -z "$wt_path" ]]; then echo >&9; exit 0; fi
                local m_dirty; m_dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
                if [[ -n "$m_dirty" && $force -eq 0 ]]; then
                  printf "%s\n" "SKIP $wt_path" >> "$results"
                else
                  if git worktree remove ${force:+--force} "$wt_path"; then
                    printf "%s\n" "OK $wt_path" >> "$results"
                  else
                    printf "%s\n" "ERR $wt_path" >> "$results"
                  fi
                fi
                echo >&9
              } &
            done <<<"$targets"
            wait
            exec 9>&- 9<&-
            while IFS= read -r line; do
              case "$line" in
                ("OK "*)    echo "üóë  Removed: ${line#OK }"; ((ok++));;
                ("SKIP "*)  echo "‚è≠Ô∏è  Skipping dirty detached worktree: ${line#SKIP } (use --force to remove)"; ((skipped++));;
                ("ERR "*)   echo "‚ùå Failed to remove: ${line#ERR }"; ((err++));;
              esac
            done < "$results"
            rm -f "$results"
          else
            # fallback to serial
            local wt_path sha dirty
            while read -r wt_path sha; do
              [[ -z "$wt_path" ]] && continue
              dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
              if [[ -n "$dirty" && $force -eq 0 ]]; then
                echo "‚è≠Ô∏è  Skipping dirty detached worktree: $wt_path (use --force to remove)"
                ((skipped++)); continue
              fi
              if git worktree remove ${force:+--force} "$wt_path"; then
                echo "üóë  Removed: $wt_path"; ((ok++))
              else
                echo "‚ùå Failed to remove: $wt_path"; ((err++))
              fi
            done <<<"$targets"
          fi
        else
          # No mkfifo/seq; serial
          local wt_path sha dirty
          while read -r wt_path sha; do
            [[ -z "$wt_path" ]] && continue
            dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
            if [[ -n "$dirty" && $force -eq 0 ]]; then
              echo "‚è≠Ô∏è  Skipping dirty detached worktree: $wt_path (use --force to remove)"
              ((skipped++)); continue
            fi
            if git worktree remove ${force:+--force} "$wt_path"; then
              echo "üóë  Removed: $wt_path"; ((ok++))
            else
              echo "‚ùå Failed to remove: $wt_path"; ((err++))
            fi
          done <<<"$targets"
        fi
      fi
    fi

    echo "üßπ Pruning stale entries‚Ä¶"
    git worktree prune

    echo "‚úÖ Done. Removed: $ok  Skipped: $skipped  Errors: $err"
    return $(( err > 0 ? 1 : 0 ))
  fi

  # --- Single selection flow below ---

  # If target_branch provided, filter candidates (detached never matches here)
  local candidates
  if [[ -n "$target_branch" ]]; then
    candidates="$(printf "%s\n" "$wt_table" | awk -F'|' -v b="$target_branch" '$2==b')"
    if [[ -z "$candidates" ]]; then
      echo "‚ùå No worktree found for branch '$target_branch'."
      return 1
    fi
  else
    candidates="$wt_table"
  fi

  # If target_dir provided, select that; else pick interactively or prompt
  local picked_path picked_branch picked_head
  if [[ -n "$target_dir" ]]; then
    picked_path="$target_dir"
    picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
    picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    if [[ -z "$picked_branch" ]]; then
      # Try physical path match to handle /var vs /private/var and symlinks
      local target_phys
      target_phys="$(cd "$picked_path" 2>/dev/null && pwd -P || printf "%s" "$picked_path")"
      local row
      local IFS=$'\n'
      for row in ${(f)wt_table}; do
        local row_path="${row%%|*}"
        local row_phys
        row_phys="$(cd "$row_path" 2>/dev/null && pwd -P || printf "%s" "$row_path")"
        if [[ "$row_phys" == "$target_phys" ]]; then
          picked_branch="${row#*|}"; picked_branch="${picked_branch%%|*}"
          picked_head="${row##*|}"
          break
        fi
      done
    fi
    [[ -z "$picked_branch" ]] && { echo "‚ùå Not a registered worktree: $picked_path"; return 1; }
  else
    # Display: "branch[+sha]   path"
    local display
    display="$(printf "%s\n" "$candidates" \
      | awk -F'|' '{b=$2; h=$3; if (b=="(detached)") b=b "@" substr(h,1,7); printf "%-40s  %s\n", b, $1}')"

    if (( no_fzf )) || [[ -n $FZF_MISSING ]]; then
      echo "üß≠ Select a worktree to remove:"
      printf "%s\n" "$display"
      printf "Choice (type full path): "
      read -r picked_path
      [[ -z "$picked_path" ]] && { echo "‚ùå No selection."; return 1; }
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    else
      local pick_out
      pick_out="$(printf "%s\n" "$display" \
        | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
              --prompt="üßπ Remove worktree: " \
              --preview '
                  path=$(echo {} | awk "{print $NF}")
                  if [[ -d "$path" ]]; then
                    printf "Path: %s\n\n" "$path"
                    git -C "$path" status -sb --untracked-files=all 2>/dev/null
                    echo
                    printf "Recent commits:\n"
                    git -C "$path" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null
                  else
                    echo "Path missing on disk."
                  fi
              ' \
              --preview-window=right,60%)" || { echo "‚ùå No selection."; return 1; }
      picked_path="$(printf "%s" "$pick_out" | awk '{print $NF}')"
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    fi
  fi

  [[ -z "$picked_path" ]] && { echo "‚ùå Could not determine worktree path."; return 1; }
  [[ "$picked_path" == "$(pwd)" || "$(pwd)"/ == "$picked_path"/* ]] && {
    echo "‚ùå You are currently inside '$picked_path'. cd elsewhere first."; return 1;
  }

  # --- Safety checks in that worktree ---
  # 1) Dirty?
  local dirty
  dirty="$(git -C "$picked_path" status --porcelain --untracked-files=all 2>/dev/null)"
  if [[ -n "$dirty" && $force -eq 0 ]]; then
    echo "‚ùå Worktree has uncommitted/untracked changes."
    
    # Offer recovery options
    if typeset -f wt_show_hints >/dev/null 2>&1; then
      wt_show_hints untracked_changes "$picked_path"
      echo ""
      printf "üí° Options:\n"
      echo "   [1] Commit changes now"
      echo "   [2] Stash changes"  
      echo "   [3] Use --force to remove anyway (‚ö†Ô∏è  LOSES CHANGES)"
      echo "   [4] Cancel"
      printf "   Choice [1-4]: "
      
      local recovery_choice
      read -r recovery_choice
      
      case "$recovery_choice" in
        1)
          echo ""
          echo "üìù Committing changes in $picked_path..."
          printf "Commit message: "
          local commit_msg
          read -r commit_msg
          if [[ -n "$commit_msg" ]]; then
            (cd "$picked_path" && git add -A && git commit -m "$commit_msg") || {
              echo "‚ùå Commit failed"
              return 1
            }
            echo "‚úÖ Changes committed, continuing..."
            dirty=""  # Clear dirty flag
          else
            echo "‚ùå Empty commit message, cancelled"
            return 1
          fi
          ;;
        2)
          echo ""
          echo "üì¶ Stashing changes in $picked_path..."
          (cd "$picked_path" && git stash push -u -m "wtrm auto-stash $(date +%Y-%m-%d_%H:%M:%S)") || {
            echo "‚ùå Stash failed"
            return 1
          }
          echo "‚úÖ Changes stashed, continuing..."
          dirty=""  # Clear dirty flag
          ;;
        3)
          echo ""
          echo "‚ö†Ô∏è  Forcing removal with uncommitted changes..."
          force=1
          ;;
        *)
          echo "‚ùé Cancelled"
          return 1
          ;;
      esac
    else
      echo "   Use --force to remove anyway."
      return 1
    fi
  fi

  # 2) Ahead of upstream? If no upstream, allow removal (previous behavior/tests expect this)
  local ahead=0 behind=0 upstream=""
  upstream="$(git -C "$picked_path" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
  if [[ -n "$upstream" ]]; then
    local lr
    lr="$(git -C "$picked_path" rev-list --left-right --count "${upstream}...HEAD" 2>/dev/null || echo "0 0")"
    behind="$(echo "$lr" | awk '{print $1}')"   # commits behind upstream
    ahead="$(echo  "$lr" | awk '{print $2}')"   # commits ahead of upstream
    if (( ahead > 0 && force == 0 )); then
      echo "‚ùå Branch '$picked_branch' is ahead of '$upstream' by $ahead commit(s)."
      
      # Offer recovery options
      if typeset -f wt_show_hints >/dev/null 2>&1; then
        echo ""
        printf "üí° Options:\n"
        echo "   [1] Push commits now"
        echo "   [2] Use --force to remove anyway (‚ö†Ô∏è  LOSES COMMITS)"
        echo "   [3] Cancel"
        printf "   Choice [1-3]: "
        
        local recovery_choice
        read -r recovery_choice
        
        case "$recovery_choice" in
          1)
            echo ""
            echo "üåê Pushing commits..."
            (cd "$picked_path" && git push) || {
              echo "‚ùå Push failed"
              return 1
            }
            echo "‚úÖ Commits pushed, continuing..."
            ;;
          2)
            echo ""
            echo "‚ö†Ô∏è  Forcing removal with unpushed commits..."
            force=1
            ;;
          *)
            echo "‚ùé Cancelled"
            return 1
            ;;
        esac
      else
        echo "   Push or use --force."
        return 1
      fi
    fi
  fi

  # --- Remove the worktree ---
  echo "üóë  Removing worktree:"
  echo "    Path:   $picked_path"
  echo "    Branch: $picked_branch"
  
  # Record transaction for potential rollback
  if typeset -f wt_transaction_record >/dev/null 2>&1; then
    wt_transaction_record "worktree_remove" "$picked_path"
  fi
  
  if ! git worktree remove "${force:+--force}" "$picked_path" 2>/dev/null; then
    echo "‚ùå Failed to remove worktree."
    
    # Diagnose and offer recovery
    if typeset -f wt_diagnose_error >/dev/null 2>&1; then
      echo ""
      echo "üí° Possible causes:"
      echo "   ‚Ä¢ Worktree is locked"
      echo "   ‚Ä¢ Worktree is currently in use"
      echo "   ‚Ä¢ Uncommitted changes (use --force)"
      echo ""
      printf "Try with --force? [y/N]: "
      local try_force
      read -r try_force
      if [[ "${try_force:l}" == "y" ]]; then
        git worktree remove --force "$picked_path" || {
          echo "‚ùå Force removal also failed"
          return 1
        }
      else
        return 1
      fi
    else
      return 1
    fi
  fi

  echo "üßπ Pruning stale entries‚Ä¶"
  git worktree prune

  # --- Optionally delete the local branch (if merged) ---
  if (( delete_branch )); then
    if [[ -n "$picked_branch" && "$picked_branch" != "(detached)" ]]; then
      local still_used
      still_used="$(wt_parse_worktrees_table "$(git worktree list --porcelain 2>/dev/null)" | awk -F'|' -v b="$picked_branch" '$2==b{print $1}')"
      if [[ -n "$still_used" ]]; then
        echo "‚ÑπÔ∏è  Branch '$picked_branch' still used by another worktree; skipping branch delete."
      else
        if [[ -z "$base_ref" ]]; then
          for guess in origin/main origin/master main master; do
            if git rev-parse --verify -q "$guess" >/dev/null; then base_ref="$guess"; break; fi
          done
        fi
        if [[ -z "$base_ref" ]]; then
          echo "‚ö†Ô∏è  No base ref found to check mergedness; skipping branch delete."
        else
          if git merge-base --is-ancestor "refs/heads/$picked_branch" "$base_ref"; then
            echo "üß® Deleting local branch '$picked_branch' (merged into $base_ref)‚Ä¶"
            git branch -d "$picked_branch" || true
          else
            echo "‚ö†Ô∏è  Branch '$picked_branch' is not fully merged into $base_ref; skipping branch delete."
          fi
        fi
      fi
    fi
  fi

  echo "‚úÖ Done."
  
  # Commit transaction on success
  if typeset -f wt_transaction_commit >/dev/null 2>&1; then
    wt_transaction_commit
    trap - EXIT INT TERM
  fi
}