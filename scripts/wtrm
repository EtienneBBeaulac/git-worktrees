# wtrm: safely remove a Git worktree (with fzf picker)
# Usage:
#   wtrm                          # pick interactively
#   wtrm -d /path/to/worktree     # remove by path
#   wtrm -b feature/xyz           # remove the worktree hosting this branch
# Options:
#   -d, --dir <path>          Worktree directory to remove
#   -b, --branch <name>       Branch whose worktree to remove (if multiple, will prompt)
#   --delete-branch           Also delete the *local* branch if fully merged into base
#   --base <ref>              Base to check mergedness (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
#   --force                   Force removal even if dirty or ahead of upstream
#   --no-fzf                  Don‚Äôt use fzf; prompt fallback if needed
#   --prune-only              Just run 'git worktree prune' and exit
#   -h, --help                Show help
wtrm() {
  local target_dir target_branch delete_branch=0 force=0 base_ref="" no_fzf=0 prune_only=0
  local FZF_MISSING=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--dir)    target_dir="$2"; shift 2;;
      -b|--branch) target_branch="$2"; shift 2;;
      --delete-branch) delete_branch=1; shift;;
      --base)      base_ref="$2"; shift 2;;
      --force)     force=1; shift;;
      --no-fzf)    no_fzf=1; shift;;
      --prune-only) prune_only=1; shift;;
      -h|--help)
        cat <<'USAGE'
wtrm: safely remove a Git worktree.
Examples:
  wtrm
  wtrm -d ../repo-feature-x
  wtrm -b feature/x --delete-branch
Options:
  -d, --dir <path>       Worktree directory to remove
  -b, --branch <name>    Branch whose worktree to remove (prompts if multiple)
  --delete-branch        Delete the local branch after removal if fully merged
  --base <ref>           Base ref for merged check (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
  --force                Force removal even if dirty or ahead of upstream
  --no-fzf               Don‚Äôt use fzf for selection
  --prune-only           Only run 'git worktree prune' and exit
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  git rev-parse --git-dir &>/dev/null || { echo "‚ùå Not a git repo"; return 1; }

  if (( prune_only )); then
    echo "üßπ Pruning stale worktrees‚Ä¶"
    git worktree prune
    return $?
  fi

  command -v fzf >/dev/null || FZF_MISSING=1

  # --- Build worktree table: path | branch | head ---
  # git worktree list --porcelain emits blocks:
  # worktree /path
  # HEAD <sha>
  # branch refs/heads/<name>   (or "branch (detached)")
  local wt_table
  wt_table="$(
    git worktree list --porcelain \
    | awk '
        BEGIN{path="";head="";br=""}
        /^worktree /{path=$2}
        /^HEAD /    {head=$2}
        /^branch /  {
          br=$0
          sub(/^branch /,"",br)
          if (br ~ /^refs\/heads\//) sub(/^refs\/heads\//,"",br)
          if (br ~ /^\(detached\)/)   br="(detached)"
          printf "%s|%s|%s\n", path, br, head
        }
      '
  )"

  [[ -z "$wt_table" ]] && { echo "‚ùå No worktrees found."; return 1; }

  # If target_branch provided, filter candidates
  local candidates
  if [[ -n "$target_branch" ]]; then
    candidates="$(printf "%s\n" "$wt_table" | awk -F'|' -v b="$target_branch" '$2==b')"
    if [[ -z "$candidates" ]]; then
      echo "‚ùå No worktree found for branch '$target_branch'."
      return 1
    fi
  else
    candidates="$wt_table"
  fi

  # If target_dir provided, select that; else pick interactively or prompt
  local picked_path picked_branch picked_head
  if [[ -n "$target_dir" ]]; then
    picked_path="$target_dir"
    # derive branch for that path
    picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
    [[ -z "$picked_branch" ]] && { echo "‚ùå Not a registered worktree: $picked_path"; return 1; }
    picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
  else
    # Prepare a nice display: "branch   path"
    local display
    display="$(printf "%s\n" "$candidates" \
      | awk -F'|' '{printf "%-40s  %s\n", $2, $1}')"

    if (( no_fzf )) || [[ -n $FZF_MISSING ]]; then
      echo "üß≠ Select a worktree to remove:"
      printf "%s\n" "$display"
      printf "Choice (type full path): "
      read -r picked_path
      [[ -z "$picked_path" ]] && { echo "‚ùå No selection."; return 1; }
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    else
      local pick_out
      pick_out="$(printf "%s\n" "$display" \
        | fzf --height=40% --reverse \
              --prompt="üßπ Remove worktree: " \
              --preview '
                  path=$(echo {} | awk "{print \$NF}")
                  if [[ -d "$path" ]]; then
                    printf "Path: %s\n\n" "$path"
                    git -C "$path" status -sb --untracked-files=all 2>/dev/null
                    echo
                    printf "Recent commits:\n"
                    git -C "$path" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null
                  else
                    echo "Path missing on disk."
                  fi
              ' \
              --preview-window=right,60%)" || { echo "‚ùå No selection."; return 1; }
      picked_path="$(printf "%s" "$pick_out" | awk '{print $NF}')"
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    fi
  fi

  [[ -z "$picked_path" ]] && { echo "‚ùå Could not determine worktree path."; return 1; }
  [[ "$picked_path" == "$(pwd)" || "$(pwd)"/ == "$picked_path"/* ]] && {
    echo "‚ùå You are currently inside '$picked_path'. cd elsewhere first."; return 1;
  }

  # --- Safety checks in that worktree ---
  # 1) Dirty?
  local dirty
  dirty="$(git -C "$picked_path" status --porcelain --untracked-files=all 2>/dev/null)"
  if [[ -n "$dirty" && $force -eq 0 ]]; then
    echo "‚ùå Worktree has uncommitted/untracked changes. Use --force to remove anyway."
    return 1
  fi

  # 2) Ahead of upstream?
  local ahead=0 behind=0 upstream=""
  upstream="$(git -C "$picked_path" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
  if [[ -n "$upstream" ]]; then
    # count ahead/behind
    local lr
    lr="$(git -C "$picked_path" rev-list --left-right --count "${upstream}...HEAD" 2>/dev/null || echo "0 0")"
    behind="$(echo "$lr" | awk '{print $1}')"   # commits the branch is behind the upstream
    ahead="$(echo  "$lr" | awk '{print $2}')"   # commits ahead of upstream
    if (( ahead > 0 && force == 0 )); then
      echo "‚ùå Branch '$picked_branch' is ahead of '$upstream' by $ahead commit(s). Push or use --force."
      return 1
    fi
  else
    # no upstream set‚Äîbe conservative unless forced
    if (( force == 0 )); then
      echo "‚ùå No upstream for '$picked_branch'. Set upstream/push first, or use --force."
      return 1
    fi
  fi

  # --- Remove the worktree ---
  echo "üóë  Removing worktree:"
  echo "    Path:   $picked_path"
  echo "    Branch: $picked_branch"
  git worktree remove "${force:+--force}" "$picked_path" || {
    echo "‚ùå Failed to remove worktree."; return 1;
  }

  echo "üßπ Pruning stale entries‚Ä¶"
  git worktree prune

  # --- Optionally delete the local branch (if merged) ---
  if (( delete_branch )); then
    # only delete local branches, never detached
    if [[ -n "$picked_branch" && "$picked_branch" != "(detached)" ]]; then
      # don't delete if any other worktree still uses this branch
      local still_used
      still_used="$(git worktree list --porcelain | awk -v b="$picked_branch" '
          /^worktree /{path=$2}
          /^branch /{
            br=$0; sub(/^branch /,"",br); sub(/^refs\/heads\//,"",br);
            if (br==b) print path
          }')"
      if [[ -n "$still_used" ]]; then
        echo "‚ÑπÔ∏è  Branch '$picked_branch' still used by another worktree; skipping branch delete."
      else
        # determine base ref for mergedness
        if [[ -z "$base_ref" ]]; then
          for guess in origin/main origin/master main master; do
            if git rev-parse --verify -q "$guess" >/dev/null; then base_ref="$guess"; break; fi
          done
        fi
        if [[ -z "$base_ref" ]]; then
          echo "‚ö†Ô∏è  No base ref found to check mergedness; skipping branch delete."
        else
          # Check mergedness: if branch tip is reachable from base
          if git merge-base --is-ancestor "refs/heads/$picked_branch" "$base_ref"; then
            echo "üß® Deleting local branch '$picked_branch' (merged into $base_ref)‚Ä¶"
            git branch -d "$picked_branch" || true
          else
            echo "‚ö†Ô∏è  Branch '$picked_branch' is not fully merged into $base_ref; skipping branch delete."
          fi
        fi
      fi
    fi
  fi

  echo "‚úÖ Done."
}