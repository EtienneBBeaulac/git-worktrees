# wtrm: safely remove a Git worktree (with fzf picker)
# Usage:
#   wtrm                              # pick interactively
#   wtrm -d /path/to/worktree         # remove by path
#   wtrm -b feature/xyz               # remove the worktree hosting this branch
#   wtrm --rm-detached [--yes]        # bulk remove detached worktrees (confirm unless --yes)
# Options:
#   -d, --dir <path>          Worktree directory to remove
#   -b, --branch <name>       Branch whose worktree to remove (if multiple, will prompt)
#   --delete-branch           Also delete the *local* branch if fully merged into base
#   --base <ref>              Base to check mergedness (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
#   --force                   Force removal even if dirty or ahead of upstream
#   --no-fzf                  Don‚Äôt use fzf; prompt fallback if needed
#   --prune-only              Just run 'git worktree prune' and exit
#   --rm-detached             Remove all detached worktrees (bulk)
#   --yes                     Non-interactive confirm (with --rm-detached)
#   -h, --help                Show help
wtrm() {
  emulate -L zsh
  setopt local_options pipefail no_xtrace

  # Source common helpers if available
  local __WT_LIB="${0:A:h}/lib/wt-common.zsh"
  [[ -f "$__WT_LIB" ]] && source "$__WT_LIB"

  local target_dir target_branch delete_branch=0 force=0 base_ref="" no_fzf=0 prune_only=0
  local rm_detached=0 assume_yes=0 jobs_opt=""
  local FZF_MISSING=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--dir)        target_dir="$2"; shift 2;;
      -b|--branch)     target_branch="$2"; shift 2;;
      --delete-branch) delete_branch=1; shift;;
      --base)          base_ref="$2"; shift 2;;
      --force)         force=1; shift;;
      --no-fzf)        no_fzf=1; shift;;
      --prune-only)    prune_only=1; shift;;
      --rm-detached)   rm_detached=1; shift;;
      --jobs)          jobs_opt="$2"; shift 2;;
      --yes)           assume_yes=1; shift;;
      -h|--help)
        cat <<'USAGE'
wtrm: safely remove a Git worktree.

Examples:
  wtrm
  wtrm -d ../repo-feature-x
  wtrm -b feature/x --delete-branch
  wtrm --rm-detached --yes

Options:
  -d, --dir <path>       Worktree directory to remove
  -b, --branch <name>    Branch whose worktree to remove (prompts if multiple)
  --delete-branch        Delete the local branch after removal if fully merged
  --base <ref>           Base ref for merged check (default: origin/main‚Üíorigin/master‚Üímain‚Üímaster)
  --force                Force removal even if dirty or ahead of upstream
  --no-fzf               Don‚Äôt use fzf for selection
  --prune-only           Only run 'git worktree prune' and exit
  --rm-detached          Remove all detached worktrees
  --jobs <N>             Max parallel removals when using --rm-detached (smart default)
  --yes                  Skip confirmation (used with --rm-detached)
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  git rev-parse --git-dir &>/dev/null || { echo "‚ùå Not a git repo"; return 1; }

  # Keep remotes up-to-date (optional, consistent with wtnew)
  echo "üîÑ  Fetching remotes‚Ä¶"
  git fetch --all --prune --tags --quiet || true

  if (( prune_only )); then
    echo "üßπ Pruning stale worktrees‚Ä¶"
    git worktree prune
    return $?
  fi

  command -v fzf >/dev/null || FZF_MISSING=1

  # --- Build worktree table: path | branch | head ---
  # git worktree list --porcelain emits blocks:
  # worktree /path
  # HEAD <sha>
  # branch refs/heads/<name>   (or omitted when detached)
  local wt_table
  wt_table="$(
    git worktree list --porcelain |
    awk '
      BEGIN { path=""; head=""; br="" }
      function flush() {
        if (path != "") {
          if (br == "") br="(detached)";
          printf "%s|%s|%s\n", path, br, head
        }
      }
      /^worktree / { flush(); path=$2; head=""; br=""; next }
      /^HEAD /     { head=$2; next }
      /^branch /   {
        br=$0
        sub(/^branch /,"",br)
        sub(/^refs\/heads\//,"",br)
        next
      }
      END { flush() }
    '
  )"

  [[ -z "$wt_table" ]] && { echo "‚ùå No worktrees found."; return 1; }

  # --- Bulk removal of detached worktrees ---
  if (( rm_detached )); then
    local det_list det_count
    det_list="$(printf "%s\n" "$wt_table" | awk -F'|' '$2=="(detached)" {printf "%s %s\n", $1, $3}')"
    det_count="$(printf "%s\n" "$det_list" | sed '/^\s*$/d' | wc -l | tr -d ' ')"
    if [[ -z "$det_list" ]]; then
      echo "‚ÑπÔ∏è  No detached worktrees found."
      return 0
    fi

    echo "üß≠ Detached worktrees to remove ($det_count):"
    printf "%s\n" "$det_list" | awk '{printf "  - %s (HEAD %s)\n", $1, substr($2,1,7)}'

    if (( !assume_yes )); then
      printf "Proceed? [y/N]: "
      local ans; read -r ans
      [[ "$ans" == "y" || "$ans" == "Y" ]] || { echo "‚ùé Cancelled."; return 1; }
    fi

    local ok=0 skipped=0 err=0
    local targets; targets="$(printf "%s\n" "$det_list" | sed '/^\s*$/d')"
    local total; total="$(printf "%s\n" "$targets" | wc -l | tr -d ' ')"
    local jobs=${jobs_opt:-${WTRM_JOBS:-4}}
    (( total <= 3 )) && jobs=1
    (( jobs > total )) && jobs=$total

    if (( jobs <= 1 )); then
      local wt_path sha dirty
      while read -r wt_path sha; do
        [[ -z "$wt_path" ]] && continue
        dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
        if [[ -n "$dirty" && $force -eq 0 ]]; then
          echo "‚è≠Ô∏è  Skipping dirty detached worktree: $wt_path (use --force to remove)"
          ((skipped++)); continue
        fi
        if git worktree remove ${force:+--force} "$wt_path"; then
          echo "üóë  Removed: $wt_path"; ((ok++))
        else
          echo "‚ùå Failed to remove: $wt_path"; ((err++))
        fi
      done <<<"$targets"
    else
      # parallel
      local fifo; fifo=$(mktemp -u)
      mkfifo "$fifo" || { echo "‚ùå mkfifo failed"; return 1; }
      exec 9<>"$fifo"; rm -f "$fifo"
      local i; for i in $(seq 1 $jobs); do echo >&9; done
      while read -r wt_path sha; do
        read -u 9
        {
          if [[ -z "$wt_path" ]]; then echo >&9; exit 0; fi
          local m_dirty; m_dirty="$(git -C "$wt_path" status --porcelain --untracked-files=all 2>/dev/null)"
          if [[ -n "$m_dirty" && $force -eq 0 ]]; then
            echo "SKIP $wt_path"
          else
            if git worktree remove ${force:+--force} "$wt_path"; then
              echo "OK $wt_path"
            else
              echo "ERR $wt_path"
            fi
          fi
          echo >&9
        } &
      done <<<"$targets"
      wait
      exec 9>&- 9<&-
      # summarize from background outputs already printed
      # Note: outputs already streamed; for concise summary we re-count lines
      ok=$(printf "%s\n" | wc -l | tr -d ' ')
      skipped=$(printf "%s\n" | wc -l | tr -d ' ')
      err=$(printf "%s\n" | wc -l | tr -d ' ')
    fi

    echo "üßπ Pruning stale entries‚Ä¶"
    git worktree prune

    echo "‚úÖ Done. Removed: $ok  Skipped: $skipped  Errors: $err"
    return $(( err > 0 ? 1 : 0 ))
  fi

  # --- Single selection flow below ---

  # If target_branch provided, filter candidates (detached never matches here)
  local candidates
  if [[ -n "$target_branch" ]]; then
    candidates="$(printf "%s\n" "$wt_table" | awk -F'|' -v b="$target_branch" '$2==b')"
    if [[ -z "$candidates" ]]; then
      echo "‚ùå No worktree found for branch '$target_branch'."
      return 1
    fi
  else
    candidates="$wt_table"
  fi

  # If target_dir provided, select that; else pick interactively or prompt
  local picked_path picked_branch picked_head
  if [[ -n "$target_dir" ]]; then
    picked_path="$target_dir"
    picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
    [[ -z "$picked_branch" ]] && { echo "‚ùå Not a registered worktree: $picked_path"; return 1; }
    picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
  else
    # Display: "branch[+sha]   path"
    local display
    display="$(printf "%s\n" "$candidates" \
      | awk -F'|' '{b=$2; h=$3; if (b=="(detached)") b=b "@" substr(h,1,7); printf "%-40s  %s\n", b, $1}')"

    if (( no_fzf )) || [[ -n $FZF_MISSING ]]; then
      echo "üß≠ Select a worktree to remove:"
      printf "%s\n" "$display"
      printf "Choice (type full path): "
      read -r picked_path
      [[ -z "$picked_path" ]] && { echo "‚ùå No selection."; return 1; }
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    else
      local pick_out
      pick_out="$(printf "%s\n" "$display" \
        | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
              --prompt="üßπ Remove worktree: " \
              --preview '
                  path=$(echo {} | awk "{print $NF}")
                  if [[ -d "$path" ]]; then
                    printf "Path: %s\n\n" "$path"
                    git -C "$path" status -sb --untracked-files=all 2>/dev/null
                    echo
                    printf "Recent commits:\n"
                    git -C "$path" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null
                  else
                    echo "Path missing on disk."
                  fi
              ' \
              --preview-window=right,60%)" || { echo "‚ùå No selection."; return 1; }
      picked_path="$(printf "%s" "$pick_out" | awk '{print $NF}')"
      picked_branch="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $2}')"
      picked_head="$(printf "%s\n" "$wt_table" | awk -F'|' -v p="$picked_path" '$1==p{print $3}')"
    fi
  fi

  [[ -z "$picked_path" ]] && { echo "‚ùå Could not determine worktree path."; return 1; }
  [[ "$picked_path" == "$(pwd)" || "$(pwd)"/ == "$picked_path"/* ]] && {
    echo "‚ùå You are currently inside '$picked_path'. cd elsewhere first."; return 1;
  }

  # --- Safety checks in that worktree ---
  # 1) Dirty?
  local dirty
  dirty="$(git -C "$picked_path" status --porcelain --untracked-files=all 2>/dev/null)"
  if [[ -n "$dirty" && $force -eq 0 ]]; then
    echo "‚ùå Worktree has uncommitted/untracked changes. Use --force to remove anyway."
    return 1
  fi

  # 2) Ahead of upstream?
  local ahead=0 behind=0 upstream=""
  upstream="$(git -C "$picked_path" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
  if [[ -n "$upstream" ]]; then
    local lr
    lr="$(git -C "$picked_path" rev-list --left-right --count "${upstream}...HEAD" 2>/dev/null || echo "0 0")"
    behind="$(echo "$lr" | awk '{print $1}')"   # commits behind upstream
    ahead="$(echo  "$lr" | awk '{print $2}')"   # commits ahead of upstream
    if (( ahead > 0 && force == 0 )); then
      echo "‚ùå Branch '$picked_branch' is ahead of '$upstream' by $ahead commit(s). Push or use --force."
      return 1
    fi
  else
    # no upstream set‚Äîbe conservative unless forced
    if (( force == 0 )); then
      echo "‚ùå No upstream for '$picked_branch'. Set upstream/push first, or use --force."
      return 1
    fi
  fi

  # --- Remove the worktree ---
  echo "üóë  Removing worktree:"
  echo "    Path:   $picked_path"
  echo "    Branch: $picked_branch"
  git worktree remove "${force:+--force}" "$picked_path" || {
    echo "‚ùå Failed to remove worktree."; return 1;
  }

  echo "üßπ Pruning stale entries‚Ä¶"
  git worktree prune

  # --- Optionally delete the local branch (if merged) ---
  if (( delete_branch )); then
    if [[ -n "$picked_branch" && "$picked_branch" != "(detached)" ]]; then
      local still_used
      still_used="$(git worktree list --porcelain | awk -v b="$picked_branch" '
          /^worktree /{path=$2}
          /^branch /{
            br=$0; sub(/^branch /,"",br); sub(/^refs\/heads\//,"",br);
            if (br==b) print path
          }')"
      if [[ -n "$still_used" ]]; then
        echo "‚ÑπÔ∏è  Branch '$picked_branch' still used by another worktree; skipping branch delete."
      else
        if [[ -z "$base_ref" ]]; then
          for guess in origin/main origin/master main master; do
            if git rev-parse --verify -q "$guess" >/dev/null; then base_ref="$guess"; break; fi
          done
        fi
        if [[ -z "$base_ref" ]]; then
          echo "‚ö†Ô∏è  No base ref found to check mergedness; skipping branch delete."
        else
          if git merge-base --is-ancestor "refs/heads/$picked_branch" "$base_ref"; then
            echo "üß® Deleting local branch '$picked_branch' (merged into $base_ref)‚Ä¶"
            git branch -d "$picked_branch" || true
          else
            echo "‚ö†Ô∏è  Branch '$picked_branch' is not fully merged into $base_ref; skipping branch delete."
          fi
        fi
      fi
    fi
  fi

  echo "‚úÖ Done."
}