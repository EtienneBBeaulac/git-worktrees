# wtnew: create/open a Git worktree for a new or existing branch
# macOS + zsh/bash friendly. Requires: git, (optional) fzf
wtnew() {
  emulate -L zsh
  setopt local_options pipefail

  local new_branch base_ref repo default_dir wt_dir
  local open_ide=1 open_app="Android Studio"
  local explicit_remote do_push=0
  local FZF_MISSING=

  # -------- flags (optional) --------
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--name) new_branch="$2"; shift 2;;
      -b|--base) base_ref="$2"; shift 2;;
      -d|--dir)  wt_dir="$2"; shift 2;;
      -r|--remote) explicit_remote="$2"; shift 2;;
      --no-open) open_ide=0; shift;;
      --app)     open_app="$2"; shift 2;;
      --push)    do_push=1; shift;;
      -h|--help)
        cat <<'USAGE'
Usage: wtnew [options]
  -n, --name   Branch name (new or existing)
  -b, --base   Base ref (e.g., origin/main) when creating a brand-new branch
  -d, --dir    Worktree directory
  -r, --remote Remote to track/push (default: infer from base or origin)
  --no-open    Do not launch Android Studio
  --app        App name to open (default: "Android Studio")
  --push       Push new branch to the selected remote and set upstream
Notes:
  - If the branch exists locally â†’ a worktree is created on that branch.
  - If the branch exists on a remote â†’ local tracking branch is created from that remote.
  - If the branch does not exist anywhere â†’ new branch off --base (or picked interactively).
Debug:
  - Set WTNEW_DEBUG=1 to print branch/base lists and counts.
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  # -------- sanity checks --------
  git rev-parse --git-dir &>/dev/null || { echo "âŒ Not a git repo"; return 1; }
  command -v fzf >/dev/null || FZF_MISSING=1

  echo "ðŸ”„  Fetching remotesâ€¦"
  git fetch --all --prune --tags --quiet || true

  # Validate explicit remote if provided
  if [[ -n ${explicit_remote:-} ]] && ! git remote | grep -Fxq "$explicit_remote"; then
    echo "âŒ Unknown remote: $explicit_remote"
    echo "   Available remotes: $(git remote | tr '\n' ' ')"
    return 1
  fi

  # -------- helper: build list of short refs (no refs/â€¦ prefixes) --------
  _wt__branch_list() {
    git for-each-ref --format='%(refname:short)' refs/heads refs/remotes \
    | sed -E 's#^refs/heads/##; s#^refs/remotes/##; s#^remotes/##' \
    | grep -vE '^(HEAD|.*/HEAD)$' \
    | sort -u
  }

  # -------- branch name (fzf with free-typing) --------
  if [[ -z ${new_branch:-} ]]; then
    if [[ -z $FZF_MISSING ]]; then
      local all_branches out query choice
      all_branches="$(_wt__branch_list)"
      if [[ -n ${WTNEW_DEBUG:-} ]]; then
        echo "DBG branches count: $(printf "%s\n" "$all_branches" | sed '/^$/d' | wc -l)" >&2
        printf "%s\n" "$all_branches" >&2
      fi
      [[ -z "$all_branches" ]] && { echo "âŒ No branches found. Try: git fetch --all --prune --tags"; return 1; }

      out="$(printf "%s\n" "$all_branches" \
        | fzf --height=40% --reverse \
              --prompt="ðŸ†•  Branch (type to create OR pick existing): " \
              --preview 'if [ -n "{}" ] && git rev-parse --verify -q {} >/dev/null; then \
                            git log --oneline -n 20 --decorate --graph --color=always {}; \
                          else echo "âž• New branch"; fi' \
              --preview-window=right,60% \
              --print-query)"
      local fzf_status=$?

      query="$(printf "%s" "$out" | head -n1)"
      choice="$(printf "%s" "$out" | tail -n1)"

      # If user cancelled (Esc/Ctrl-C), fzf returns non-zero and no output
      if (( fzf_status != 0 )) && [[ -z "$query" && -z "$choice" ]]; then
        echo "âŒ No branch chosen"; return 1
      fi

      if [[ -n "$choice" && "$choice" != "$query" ]]; then
        new_branch="$choice"
      else
        new_branch="$query"
      fi
    else
      printf "ðŸ†•  Branch name (new or existing): "; read -r new_branch
    fi
  fi
  [[ -z $new_branch ]] && { echo "âŒ Branch name required"; return 1; }

  # -------- normalize selection into remote + short branch --------
  local sel="$new_branch" remote_name="" short_branch=""
  if [[ "$sel" =~ ^refs/remotes/([^/]+)/(.+)$ ]]; then
    remote_name="${match[1]}"; short_branch="${match[2]}"
  elif [[ "$sel" =~ ^remotes/([^/]+)/(.+)$ ]]; then
    remote_name="${match[1]}"; short_branch="${match[2]}"
  elif git remote | grep -Fxq "${sel%%/*}" && [[ "$sel" == */* ]]; then
    remote_name="${sel%%/*}"; short_branch="${sel#*/}"
  else
    short_branch="$sel"
  fi
  new_branch="$short_branch"

  # sanitize & validate local branch name
  local sane_branch
  sane_branch=$(printf "%s" "$new_branch" \
    | tr ' ' '-' \
    | sed 's#[^A-Za-z0-9/_\-]##g')
  git check-ref-format --branch "$sane_branch" \
    || { echo "âŒ Invalid branch name: $sane_branch"; return 1; }
  new_branch="$sane_branch"

  # -------- existence checks across local + any remote --------
  local local_exists=0 remote_exists=0 remote_found=""
  git show-ref --verify --quiet "refs/heads/$new_branch" && local_exists=1

  if [[ -n "$remote_name" ]] && git show-ref --verify --quiet "refs/remotes/$remote_name/$new_branch"; then
    remote_exists=1; remote_found="$remote_name"
  else
    remote_found="$(git for-each-ref --format='%(refname:short)' "refs/remotes/*/$new_branch" | awk -F/ 'NF>=3{print $2; exit}')"
    [[ -n "$remote_found" ]] && remote_exists=1
  fi

  # -------- base ref selection (only for brand-new branches) --------
  if (( !local_exists && !remote_exists )); then
    if [[ -z ${base_ref:-} ]]; then
      for guess in origin/main origin/master main master origin/develop develop; do
        if git rev-parse --verify -q "$guess" >/dev/null; then
          base_ref="$guess"; break
        fi
      done
    fi
    if [[ -z ${base_ref:-} ]]; then
      local branch_list="$(_wt__branch_list)"
      if [[ -n ${WTNEW_DEBUG:-} ]]; then
        echo "DBG base list count: $(printf "%s\n" "$branch_list" | sed '/^$/d' | wc -l)" >&2
        printf "%s\n" "$branch_list" >&2
      fi
      if [[ -n $FZF_MISSING ]]; then
        echo "ðŸ“  Branches available (pick base):"
        printf "%s\n" "$branch_list"
        printf "â›“  Base ref: "; read -r base_ref
      else
        base_ref="$(printf "%s\n" "$branch_list" \
          | fzf --height=40% --reverse \
                --prompt="â›“  Base ref: " \
                --preview 'if [ -n "{}" ] && git rev-parse --verify -q {} >/dev/null; then \
                             git log --oneline -n 30 --decorate --graph --color=always {}; \
                           else echo "invalid ref"; fi' \
                --preview-window=right,60%)"
      fi
    fi
    [[ -z $base_ref ]] && { echo "âŒ No base ref selected"; return 1; }
    git rev-parse --verify -q "$base_ref" >/dev/null \
      || { echo "âŒ Unknown base ref: $base_ref"; return 1; }
  fi

  # -------- worktree dir (sibling of repo root, never nested) --------
  local repo_root repo parent_dir
  repo_root="$(git rev-parse --show-toplevel)"
  repo="$(basename "$repo_root")"
  parent_dir="$(dirname "$repo_root")"
  default_dir="${parent_dir}/${repo}-${new_branch//\//-}"
  if [[ -z ${wt_dir:-} ]]; then
    printf "ðŸ“‚  Worktree dir [%s]: " "$default_dir"; read -r wt_dir
    wt_dir=${wt_dir:-$default_dir}
  fi
  # Normalize to absolute paths for validation
  local wt_dir_abs="${wt_dir:A}"
  local repo_root_abs="${repo_root:A}"

  # Disallow creating a worktree inside the current repository
  if [[ "$wt_dir_abs" == "$repo_root_abs" || "$wt_dir_abs" == $repo_root_abs/* ]]; then
    echo "âŒ Worktree path cannot be inside the current repository: $wt_dir"
    echo "   Pick a path outside, e.g.: $default_dir"
    return 1
  fi

  [[ -e "$wt_dir_abs" ]] && { echo "âŒ Path already exists: $wt_dir"; return 1; }
  if git worktree list --porcelain | awk '/^worktree /{print $2}' | grep -Fxq "$wt_dir_abs"; then
    echo "âŒ Worktree already registered at: $wt_dir"; return 1
  fi

  # Use absolute path going forward
  wt_dir="$wt_dir_abs"

  # -------- choose remote to track/push --------
  local selected_remote=""
  if [[ -n ${explicit_remote:-} ]]; then
    selected_remote="$explicit_remote"
  elif (( remote_exists )); then
    selected_remote="$remote_found"
  elif [[ "${base_ref:-}" == */* ]]; then
    selected_remote="${base_ref%%/*}"
  elif git remote | grep -Fxq origin >/dev/null 2>&1; then
    selected_remote="origin"
  else
    selected_remote="$(git remote | head -n1)"
  fi

  # -------- create worktree (3 cases) --------
  echo "âž•  Creating worktreeâ€¦"
  if (( local_exists )); then
    git worktree add "$wt_dir" "$new_branch" \
      || { echo "âŒ worktree add failed"; return 1; }
  elif (( remote_exists )); then
    git worktree add -b "$new_branch" "$wt_dir" "${remote_found}/${new_branch}" \
      || { echo "âŒ worktree add failed"; return 1; }
  else
    git worktree add -b "$new_branch" "$wt_dir" "$base_ref" \
      || { echo "âŒ worktree add failed"; return 1; }
  fi

  # -------- upstream setup / push (optional) --------
  if (( remote_exists )); then
    (cd "$wt_dir" && git branch --set-upstream-to="${remote_found}/${new_branch}" >/dev/null 2>&1 || true)
  else
    # If no remote branch exists and --push requested, create it and set upstream
    if (( do_push )) && [[ -n "$selected_remote" ]]; then
      echo "ðŸŒ  Pushing to $selected_remote and setting upstreamâ€¦"
      (cd "$wt_dir" && git push -u "$selected_remote" "$new_branch" >/dev/null 2>&1 || true)
    fi
  fi

  # submodules (if present)
  if [[ -f .gitmodules ]] && grep -q 'path = ' .gitmodules 2>/dev/null; then
    echo "ðŸ”  Updating submodulesâ€¦"
    (cd "$wt_dir" && git submodule update --init --recursive --quiet)
  fi

  # -------- open IDE (robust macOS chain) --------
  if (( open_ide )); then
    echo "ðŸš€  Opening Android Studioâ€¦"

    if command -v studio >/dev/null 2>&1; then
      studio "$wt_dir" >/dev/null 2>&1 || true
    else
      if [[ -d "$wt_dir/.idea" ]]; then
        open -a "$open_app" "$wt_dir/.idea" >/dev/null 2>&1 || true
      elif [[ -f "$wt_dir/settings.gradle" || -f "$wt_dir/settings.gradle.kts" ]]; then
        local sg="$wt_dir/settings.gradle"
        [[ -f "$wt_dir/settings.gradle.kts" ]] && sg="$wt_dir/settings.gradle.kts"
        open -a "$open_app" "$sg" >/dev/null 2>&1 || true
      elif [[ -f "$wt_dir/build.gradle" || -f "$wt_dir/build.gradle.kts" ]]; then
        local bg="$wt_dir/build.gradle"
        [[ -f "$wt_dir/build.gradle.kts" ]] && bg="$wt_dir/build.gradle.kts"
        open -a "$open_app" "$bg" >/dev/null 2>&1 || true
      else
        open -a "$open_app" "$wt_dir" >/dev/null 2>&1 || true
      fi
    fi
    echo "ðŸ“‚  If no window appears, open it manually via File â†’ Openâ€¦ â†’ $wt_dir"
  else
    echo "âœ…  Worktree ready at: $wt_dir"
  fi
}