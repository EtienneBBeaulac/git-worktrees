# wtnew: create/open a Git worktree for a new or existing branch
# Requires: git, (optional) fzf

emulate -L zsh
source "${${(%):-%x}:A:h}/lib/wt-common.zsh" || return 1

wtnew() {
  emulate -L zsh
  setopt local_options pipefail no_xtrace

  # helpers are sourced at load time
  
  # Transaction: always commit on exit (records what happened for debugging)
  # Plain 'return' works everywhere - no special handling needed
  if wt_recovery_enabled 2>/dev/null; then
    wt_transaction_begin
    trap 'wt_transaction_commit 2>/dev/null || true' EXIT INT TERM
  fi

  local new_branch base_ref repo default_dir wt_dir
  local open_ide=1 open_app=""
  local explicit_remote do_push=0 inside_ok=0
  local prefer_reuse=0 reuse_slot=0 skip_create=0
  local FZF_MISSING=
  
  # Load editor configuration and detect if not set
  wt_load_editor_config 2>/dev/null || true

  # -------- flags (optional) --------
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--name)
        if [[ -n ${new_branch:-} ]]; then
          echo "Error: Branch already specified as '$new_branch', cannot also use -n '$2'"
          return 2
        fi
        new_branch="$2"; shift 2;;
      -b|--base) base_ref="$2"; shift 2;;
      -d|--dir)  wt_dir="$2"; shift 2;;
      -r|--remote) explicit_remote="$2"; shift 2;;
      --no-open) open_ide=0; shift;;
      --app)     open_app="$2"; shift 2;;
      --push)    do_push=1; shift;;
      --prefer-reuse) prefer_reuse=1; shift;;
      --inside-ok) inside_ok=1; shift;;
      -v|--version)
        echo "git-worktrees wtnew v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wtnew [options] [branch-name]

Arguments:
  branch-name  Branch name (new or existing) - same as -n/--name

Options:
  -n, --name   Branch name (alternative to positional argument)
  -b, --base   Base ref (e.g., origin/main) when creating a brand-new branch
  -d, --dir    Worktree directory
  -r, --remote Remote to track/push (default: infer from base or origin)
  --no-open    Do not open in editor/IDE
  --app        App name to open (default: auto-detected)
  --push       Push new branch to the selected remote and set upstream
  --prefer-reuse  Prefer reusing an existing worktree slot (clean, safe) over creating a new dir
  --inside-ok  Allow creating a worktree path inside current repo (unsafe)

Notes:
  - If the branch exists locally ‚Üí a worktree is created on that branch.
  - If the branch exists on a remote ‚Üí local tracking branch is created from that remote.
  - If the branch does not exist anywhere ‚Üí new branch off --base (or picked interactively).

Examples:
  wtnew feature/my-branch              # Create/open worktree for branch
  wtnew feature/new -b main            # New branch from main
  wtnew feature/new --push             # Create and push to remote

Debug:
  - Set WTNEW_DEBUG=1 to print branch/base lists and counts.
USAGE
        return 0;;
      -*)
        echo "Unknown option: $1"; return 2;;
      *)
        # Positional argument = branch name
        if [[ -z ${new_branch:-} ]]; then
          new_branch="$1"
        else
          echo "Error: Branch already specified as '$new_branch', got extra argument '$1'"
          return 2
        fi
        shift;;
    esac
  done

  # Env default: always push new branches if WTNEW_ALWAYS_PUSH is set
  if (( do_push == 0 )) && [[ -n ${WTNEW_ALWAYS_PUSH:-} ]]; then
    do_push=1
  fi
  # Env default: prefer slot reuse if WTNEW_PREFER_REUSE is set
  if (( prefer_reuse == 0 )) && [[ -n ${WTNEW_PREFER_REUSE:-} ]]; then
    prefer_reuse=1
  fi

  # -------- sanity checks --------
  if ! wt_git_is_repo; then
    wt_msg_error "Not a git repo"
    echo ""
    echo "üí° Hint: Run this command from inside a git repository"
    echo "   Or initialize one with: git init"
    return 1
  fi
  # Use centralized FZF detection
  wt_has_fzf || FZF_MISSING=1

  wt_fetch_remotes_safe

  # Validate explicit remote if provided
  if [[ -n ${explicit_remote:-} ]] && ! git remote | grep -Fxq "$explicit_remote"; then
    wt_msg_error "Unknown remote: $explicit_remote"
    echo "   Available remotes: $(git remote | tr '\n' ' ')"
    
    # Offer fuzzy match suggestion
    local all_remotes=$(git remote)
    local closest=$(echo "$all_remotes" | grep -i "$explicit_remote" | head -1)
    if [[ -n "$closest" ]]; then
      if wt_is_interactive; then
        echo ""
        echo "üí° Did you mean: $closest?"
        printf "   Use '$closest'? [Y/n]: "
        local use_closest; read -r use_closest
        if [[ "${use_closest:l}" != "n" ]]; then
          explicit_remote="$closest"
          echo "   Using: $explicit_remote"
        else
          return 1
        fi
      else
        # Non-interactive: use the closest match automatically
        wt_msg_info "Using closest match: $closest"
        explicit_remote="$closest"
      fi
    else
      return 1
    fi
  fi

  # -------- helper: build list of short refs (no refs/‚Ä¶ prefixes) --------
  _wt__branch_list() {
    git for-each-ref --format='%(refname:short)' refs/heads refs/remotes \
    | sed -E 's#^refs/heads/##; s#^refs/remotes/##; s#^remotes/##' \
    | grep -vE '^(HEAD|.*/HEAD)$' \
    | sort -u
  }

  # -------- branch name (fzf with free-typing) --------
  if [[ -z ${new_branch:-} ]]; then
    if [[ -z $FZF_MISSING ]]; then
      local all_branches out query choice
      all_branches="$(_wt__branch_list)"
      if [[ -n ${WT_DEBUG:-${WTNEW_DEBUG:-}} ]]; then
        echo "DBG branches count: $(printf "%s\n" "$all_branches" | sed '/^$/d' | wc -l)" >&2
        printf "%s\n" "$all_branches" >&2
      fi
      [[ -z "$all_branches" ]] && { wt_msg_error "No branches found. Try: git fetch --all --prune --tags"; return 1; }

      # Show discovery hint
      wt_show_contextual_help branch_selection

      out="$(printf "%s\n" "$all_branches" \
        | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
              --prompt="üÜï  Branch (type to create OR pick existing): " \
              --header="Type to filter or create new ¬∑ Enter=select ¬∑ Esc=cancel" \
              --preview 'if [ -n "{}" ] && git rev-parse --verify -q {} >/dev/null; then \
                            git log --oneline -n 20 --decorate --graph --color=always {}; \
                          else echo "‚ûï New branch"; fi' \
              --preview-window=right,60% \
              --print-query)"
      local fzf_status=$?

      query="$(printf "%s" "$out" | head -n1)"
      choice="$(printf "%s" "$out" | tail -n1)"

      # If user cancelled (Esc/Ctrl-C), fzf returns non-zero and no output
      if (( fzf_status != 0 )) && [[ -z "$query" && -z "$choice" ]]; then
        wt_msg_error "No branch chosen"; return 1
      fi

      if [[ -n "$choice" && "$choice" != "$query" ]]; then
        new_branch="$choice"
        echo "‚úì Selected: $new_branch"
      else
        new_branch="$query"
        echo "‚úì Creating new branch: $new_branch"
      fi
    else
      # Non-FZF mode: prompt for branch name
      if wt_is_interactive; then
        printf "üÜï  Branch name (new or existing): "; read -r new_branch
      else
        wt_msg_error "Branch name required"
        wt_msg_info "Provide branch name as argument: wtnew <branch-name>"
        return 1
      fi
    fi
  fi
  [[ -z $new_branch ]] && { wt_msg_error "Branch name required"; return 1; }

  # -------- normalize selection into remote + short branch --------
  local sel="$new_branch" remote_name="" short_branch=""
  if [[ "$sel" =~ ^refs/remotes/([^/]+)/(.+)$ ]]; then
    remote_name="${match[1]}"; short_branch="${match[2]}"
  elif [[ "$sel" =~ ^remotes/([^/]+)/(.+)$ ]]; then
    remote_name="${match[1]}"; short_branch="${match[2]}"
  elif git remote | grep -Fxq "${sel%%/*}" && [[ "$sel" == */* ]]; then
    remote_name="${sel%%/*}"; short_branch="${sel#*/}"
  else
    short_branch="$sel"
  fi
  new_branch="$short_branch"

  # Strict validation of local branch name (no mutation/sanitization)
  # Allow: alphanumeric, slashes, underscores, hyphens, and dots (for versions like release/1.0.0)
  if ! [[ "$new_branch" =~ ^[A-Za-z0-9/_.\-]+$ ]]; then
    wt_msg_error "Invalid branch name: $new_branch"; return 1
  fi
  git check-ref-format --branch "$new_branch" \
    || { wt_msg_error "Invalid branch name: $new_branch"; return 1; }

  # -------- existence checks across local + any remote --------
  local local_exists=0 remote_exists=0 remote_found=""
  git show-ref --verify --quiet "refs/heads/$new_branch" && local_exists=1

  if [[ -n "$remote_name" ]] && git show-ref --verify --quiet "refs/remotes/$remote_name/$new_branch"; then
    remote_exists=1; remote_found="$remote_name"
  else
    remote_found="$(git for-each-ref --format='%(refname:short)' "refs/remotes/*/$new_branch" | awk -F/ 'NF>=3{print $2; exit}')"
    [[ -n "$remote_found" ]] && remote_exists=1
  fi

  # -------- base ref selection (only for brand-new branches) --------
  if (( !local_exists && !remote_exists )); then
    if [[ -z ${base_ref:-} ]]; then
      # Use centralized default branch detection
      base_ref="$(wt_find_default_branch)" || true
    fi
    if [[ -z ${base_ref:-} ]]; then
      local branch_list="$(_wt__branch_list)"
      if [[ -n ${WT_DEBUG:-${WTNEW_DEBUG:-}} ]]; then
        echo "DBG base list count: $(printf "%s\n" "$branch_list" | sed '/^$/d' | wc -l)" >&2
        printf "%s\n" "$branch_list" >&2
      fi
      if [[ -n $FZF_MISSING ]]; then
        if ! wt_is_interactive; then
          wt_msg_error "Could not detect default branch and no base ref specified"
          wt_msg_info "Provide base branch: wtnew <branch-name> -b <base-branch>"
          return 1
        fi
        echo "üìù  Branches available (pick base):"
        printf "%s\n" "$branch_list"
        echo ""
        printf "‚õì  Base ref (or 'q' to cancel): "; read -r base_ref
        if [[ -z "$base_ref" || "$base_ref" == "q" || "$base_ref" == "Q" ]]; then
          wt_msg_error "Cancelled"
          return 1
        fi
      else
        base_ref="$(printf "%s\n" "$branch_list" \
          | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
                --prompt="‚õì  Base ref: " \
                --preview 'if [ -n "{}" ] && git rev-parse --verify -q {} >/dev/null; then \
                             git log --oneline -n 30 --decorate --graph --color=always {}; \
                           else echo "invalid ref"; fi' \
                --preview-window=right,60%)"
        [[ -n "$base_ref" ]] && echo "‚úì Base: $base_ref"
      fi
    fi
    [[ -z $base_ref ]] && { wt_msg_error "No base ref selected"; return 1; }
    git rev-parse --verify -q "$base_ref" >/dev/null \
      || { wt_msg_error "Unknown base ref: $base_ref"; return 1; }
  fi

  # -------- reuse existing worktree for this branch if already checked out --------
  local existing_wt_dir
  existing_wt_dir="$(wt_git_worktree_list_porcelain | awk -v b="$new_branch" '
    /^worktree /{d=$2}
    /^branch /{
      br=$0; sub(/^branch /,"",br); sub(/^refs\/heads\//,"",br);
      if (br==b) print d
    }' | head -n1)"
  if [[ -n "$existing_wt_dir" && -d "$existing_wt_dir" ]]; then
    echo "‚ôªÔ∏è  Branch already checked out in worktree: $existing_wt_dir"
    wt_dir="$existing_wt_dir"
    skip_create=1
  fi

  # -------- prefer reusing a clean worktree slot (optional) --------
  if (( skip_create == 0 && prefer_reuse == 1 )); then
    # Exclude repo root; find clean, non-busy slots
    local repo_root_reuse; repo_root_reuse="$(git rev-parse --show-toplevel)"
    local slots=""; local block
    block="$(wt_git_worktree_list_porcelain)"
    local sdir sbr sclean sbusy out lines=""
    local IFS=$'\n'
    local d_line
    # Parse blocks into dir + branch
    local parsed
    parsed="$(printf "%s" "$block" | awk '
      BEGIN{d="";br=""}
      /^worktree /{if(d!=""){print d"\t"br}; d=$2;br=""; next}
      /^branch /{br=$0; sub(/^branch /,"",br); sub(/^refs\/heads\//,"",br); next}
      /^$/       {if(d!=""){print d"\t"br; d="";br=""}}
      END        {if(d!=""){print d"\t"br}}
    ')"
    for d_line in ${(f)parsed}; do
      sdir="${d_line%%\t*}"; sbr="${d_line#*\t}"
      [[ -z "$sdir" || "$sdir" == "$repo_root_reuse" ]] && continue
      # Skip slots already hosting the target branch (handled above) or detached
      [[ "$sbr" == "$new_branch" || -z "$sbr" ]] && continue
      # Clean?
      local dirty; dirty="$(git -C "$sdir" status --porcelain --untracked-files=all 2>/dev/null)"
      sclean=1; [[ -n "$dirty" ]] && sclean=0
      # Busy (merge/rebase/cherry-pick)?
      sbusy=0
      [[ -e "$sdir/.git/MERGE_HEAD" || -d "$sdir/.git/rebase-merge" || -d "$sdir/.git/rebase-apply" || -e "$sdir/.git/CHERRY_PICK_HEAD" ]] && sbusy=1
      (( sclean == 1 && sbusy == 0 )) && lines+="$sdir\n"
    done
    if [[ -n "$lines" ]]; then
      local slot_count; slot_count="$(printf "%s" "$lines" | sed '/^$/d' | wc -l | tr -d ' ')"
      if [[ "$slot_count" == "1" ]]; then
        wt_dir="$(printf "%s" "$lines" | head -n1)"; reuse_slot=1
        echo "‚ôªÔ∏è  Reusing worktree slot: $wt_dir"
      else
        if [[ -z $FZF_MISSING ]]; then
          local out
          # Build display with branch and status
          local display; display=""
          local s; for s in ${(f)lines}; do
            local curr_br; curr_br="$(git -C "$s" rev-parse --abbrev-ref HEAD 2>/dev/null || echo detached)"
            local st; st="$(git -C "$s" status --porcelain --untracked-files=all 2>/dev/null)"; [[ -n "$st" ]] && st="dirty" || st="clean"
            display+="$(printf "%-40s  %s\n" "$curr_br" "$s")"
          done
          out="$(printf "%s" "$display" \
            | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
                  --prompt="‚ôªÔ∏è  Reuse slot for $new_branch: " \
                  --preview '
                      path=$(echo {} | awk "{print \$NF}")
                      if [[ -d "$path" ]]; then
                        printf "Path: %s\n\n" "$path"
                        git -C "$path" status -sb --untracked-files=all 2>/dev/null
                        echo
                        printf "Recent commits:\n"
                        git -C "$path" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null
                      fi
                  ' \
                  --preview-window=right,60%)" || true
          if [[ -n "$out" ]]; then
            wt_dir="$(printf "%s" "$out" | awk '{print $NF}')"; reuse_slot=1
            echo "‚ôªÔ∏è  Reusing worktree slot: $wt_dir"
          fi
        fi
      fi
    fi
  fi

  # -------- worktree dir (sibling of repo root, never nested) --------
  local repo_root repo parent_dir
  repo_root="$(git rev-parse --show-toplevel)"
  repo="$(basename "$repo_root")"
  parent_dir="$(dirname "$repo_root")"
  default_dir="${parent_dir}/${repo}-${new_branch//\//-}"
  if (( skip_create == 0 && reuse_slot == 0 )) && [[ -z ${wt_dir:-} ]]; then
    if wt_is_interactive; then
      printf "üìÇ  Worktree dir [%s]: " "$default_dir"; read -r wt_dir
      wt_dir=${wt_dir:-$default_dir}
    else
      # Non-interactive: use default directory
      wt_dir="$default_dir"
    fi
  fi
  # Normalize to absolute paths for validation
  local wt_dir_abs="${wt_dir:A}"
  local repo_root_abs="${repo_root:A}"

  # Disallow creating a worktree inside the current repository
  if (( skip_create == 0 && reuse_slot == 0 )) && (( inside_ok == 0 )) && [[ -z ${WTNEW_INSIDE_OK:-} ]] && [[ "$wt_dir_abs" == "$repo_root_abs" || "$wt_dir_abs" == $repo_root_abs/* ]]; then
    wt_msg_error "Worktree path cannot be inside the current repository: $wt_dir"
    echo "   Pick a path outside, e.g.: $default_dir"
    return 1
  fi

  if (( skip_create == 0 && reuse_slot == 0 )); then
    if [[ -e "$wt_dir_abs" ]]; then
      wt_msg_error "Path already exists: $wt_dir"
      
      # In non-interactive mode, fail immediately with clear guidance
      if ! wt_is_interactive; then
        wt_msg_info "Use --force to overwrite, --prefer-reuse to reuse, or specify different --dir"
        return 1
      fi
      
      # Offer recovery options
      wt_offer_recovery already_exists "$wt_dir"
      local recovery_choice=$?
      if (( recovery_choice == 4 )); then
        # User wants different path
        printf "Enter new path: "; read -r wt_dir
        wt_dir_abs="${wt_dir:A}"
      elif (( recovery_choice == 6 )); then
        # Reuse existing (if it's a valid worktree)
        if wt_git_worktree_list_porcelain | awk '/^worktree /{print $2}' | grep -Fxq "$wt_dir_abs"; then
          echo "‚ôªÔ∏è  Reusing existing worktree"
          skip_create=1
        else
          wt_msg_error "Path exists but is not a worktree"
          return 1
        fi
      else
        return 1
      fi
    fi
    
    if (( skip_create == 0 )) && wt_git_worktree_list_porcelain | awk '/^worktree /{print $2}' | grep -Fxq "$wt_dir_abs"; then
      wt_msg_error "Worktree already registered at: $wt_dir"; return 1
    fi
  fi

  # Use absolute path going forward
  wt_dir="$wt_dir_abs"

  # -------- choose remote to track/push --------
  local selected_remote=""
  if [[ -n ${explicit_remote:-} ]]; then
    selected_remote="$explicit_remote"
  elif (( remote_exists )); then
    selected_remote="$remote_found"
  elif [[ "${base_ref:-}" == */* ]]; then
    selected_remote="${base_ref%%/*}"
  elif git remote | grep -Fxq origin >/dev/null 2>&1; then
    selected_remote="origin"
  else
    selected_remote="$(git remote | head -n1)"
  fi

  # -------- create or reuse worktree --------
  if (( skip_create )); then
    : # nothing to do (already exists for this branch)
  elif (( reuse_slot )); then
    echo "‚ôªÔ∏è  Reusing slot and switching branch‚Ä¶"
    if (( local_exists )); then
      git -C "$wt_dir" switch "$new_branch" \
        || { wt_msg_error "Failed to switch to $new_branch in $wt_dir"; return 1; }
    elif (( remote_exists )); then
      git -C "$wt_dir" switch --track "${remote_found}/${new_branch}" \
        || git -C "$wt_dir" switch -c "$new_branch" "${remote_found}/${new_branch}" \
        || { wt_msg_error "Failed to create tracking branch $new_branch in $wt_dir"; return 1; }
    else
      git -C "$wt_dir" switch -c "$new_branch" "$base_ref" \
        || { wt_msg_error "Failed to create branch $new_branch from $base_ref in $wt_dir"; return 1; }
    fi
  else
    echo "‚ûï  Creating worktree‚Ä¶"
    
    # Record transaction for potential rollback
    wt_transaction_record "dir_create" "$wt_dir"
    
    local add_failed=0
    local add_output
    if (( local_exists )); then
      add_output=$(git worktree add "$wt_dir" "$new_branch" 2>&1) || add_failed=1
    elif (( remote_exists )); then
      add_output=$(git worktree add -b "$new_branch" "$wt_dir" "${remote_found}/${new_branch}" 2>&1) || add_failed=1
    else
      add_output=$(git worktree add -b "$new_branch" "$wt_dir" "$base_ref" 2>&1) || add_failed=1
    fi
    
    if (( add_failed )); then
      wt_msg_error "worktree add failed"
      echo "$add_output" | grep -v "^$" | head -3
      
      # Diagnose and offer recovery
      local error_type=$(wt_diagnose_error "git worktree add" "$add_output" 1)
      echo ""
      echo "üí° $(wt_error_message "$error_type")"
      
      # Offer recovery based on error type
      if [[ "$error_type" == "already_checked_out" ]]; then
        echo ""
        echo "Hint: The branch is already checked out in another worktree."
        echo "      Use 'git worktree list' to find it."
      elif [[ "$error_type" == "invalid_name" ]]; then
        echo ""
        echo "Hint: Branch name contains invalid characters."
        local sanitized=$(wt_sanitize_branch_name "$new_branch")
        echo "      Try: wtnew --name '$sanitized'"
      fi
      
      return 1
    fi
    
    # Record successful worktree creation
    wt_transaction_record "worktree_add" "$wt_dir"
  fi

  # -------- upstream setup / push (optional) --------
  if (( !skip_create )); then
    # Determine if upstream is already configured for this branch
    local existing_remote
    existing_remote="$(git -C "$wt_dir" config --get "branch.${new_branch}.remote" 2>/dev/null || true)"

    if [[ -z "$existing_remote" ]]; then
      # Prefer the discovered remote for the branch if it exists; otherwise fall back to selected_remote
      local upstream_remote=""
      if (( remote_exists )); then
        upstream_remote="$remote_found"
      else
        upstream_remote="$selected_remote"
      fi

      if [[ -n "$upstream_remote" ]]; then
        # If the remote tracking ref already exists, use git branch --set-upstream-to
        # Otherwise, write config keys directly so future pushes target the matching remote branch
        if git show-ref --verify --quiet "refs/remotes/${upstream_remote}/${new_branch}"; then
          (cd "$wt_dir" && git branch --set-upstream-to="${upstream_remote}/${new_branch}" >/dev/null 2>&1 || true)
        else
          git -C "$wt_dir" config "branch.${new_branch}.remote" "$upstream_remote" || true
          git -C "$wt_dir" config "branch.${new_branch}.merge" "refs/heads/${new_branch}" || true
        fi
      fi
    fi

    # If no remote branch exists and --push requested, create it and set upstream
    if (( do_push )) && [[ -n "$selected_remote" ]]; then
      echo "üåê  Pushing to $selected_remote and setting upstream‚Ä¶"
      local push_output
      if push_output="$(cd "$wt_dir" && git push -u "$selected_remote" "$new_branch" 2>&1)"; then
        echo "‚úÖ Pushed to $selected_remote/$new_branch"
      else
        wt_msg_warn "Push failed (worktree created successfully)"
        echo "   $push_output" | head -3
        echo ""
        echo "üí° You can push later with:"
        echo "   $(wt_cd_command "$wt_dir") && $(wt_shell_command git push -u "$selected_remote" "$new_branch")"
      fi
    fi
  fi

  # submodules (if present) - check in repo root, not current directory
  if (( !skip_create )); then
    if [[ -f "$repo_root/.gitmodules" ]] && grep -q 'path = ' "$repo_root/.gitmodules" 2>/dev/null; then
      echo "üîÅ  Updating submodules‚Ä¶"
      (cd "$wt_dir" && git submodule update --init --recursive --quiet)
    fi
  fi

  # -------- open IDE (reuse common helper when available) --------
  if (( open_ide )); then
    # Detect editor if not specified
    if [[ -z "$open_app" ]]; then
      open_app="$(wt_get_editor 2>/dev/null)" || true
    fi
    
    # Skip opening if user chose "none", but don't return early (need to cleanup transaction)
    if [[ -z "$open_app" ]]; then
      echo "‚ÑπÔ∏è  Worktree ready at: $wt_dir"
    else
      # Silent auto-open (no prompt)
      echo "üöÄ  Opening in ${open_app}‚Ä¶"
      wt_open_in_editor "$wt_dir" "$open_app"
      echo "üìÇ  If no window appears, open it manually via File ‚Üí Open‚Ä¶ ‚Üí $wt_dir"
    fi
  else
    echo "‚úÖ  Worktree ready at: $wt_dir"
  fi
  # Trap will auto-commit on exit
}