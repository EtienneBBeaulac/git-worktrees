# wtopen: find and open an existing Git worktree for a given branch
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WTOPEN__SCRIPT_FILE WTOPEN__SCRIPT_DIR WTOPEN__COMMON_LIB
WTOPEN__SCRIPT_FILE=${(%):-%N}
if [[ -n $WTOPEN__SCRIPT_FILE && -f $WTOPEN__SCRIPT_FILE ]]; then
  WTOPEN__SCRIPT_DIR="${WTOPEN__SCRIPT_FILE:A:h}"
else
  WTOPEN__SCRIPT_DIR="${0:A:h}"
fi
WTOPEN__COMMON_LIB="${WTOPEN__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WTOPEN__COMMON_LIB" ]] && source "$WTOPEN__COMMON_LIB" || true
wtopen() {
  emulate -L zsh
  setopt local_options pipefail
  unsetopt xtrace verbose
  set +xv 2>/dev/null || true

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true


  local branch_ref="" open_ide=1 open_app=""
  local force_fzf=0 list_only=0 dry_run=0 prune_stale=0 exact_match=0 prefer_cwd=0
  local FZF_MISSING=

  # -------- flags (optional) --------
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        cat <<'USAGE'
Usage: wtopen [branchOrRef] [options]
  --list         List worktrees with branches and exit
  --fzf          Force interactive picker even if branch provided
  --no-open      Do not open in editor/IDE (print path only)
  --app NAME     App name to open (default: auto-detected)
  --prune-stale  Prune stale/prunable worktrees and exit
  --dry-run      Show which directory would be opened; do not open
  --exact        Require exact branch match (no shortname normalization)
  --cwd          Prefer matches from the current repo family if multiple
  -h, --help     Show help
Debug:
  - Set WT_DEBUG=1 to print internal lists.
USAGE
        return 0;;
      --list)        list_only=1; shift;;
      --fzf)         force_fzf=1; shift;;
      --no-open)     open_ide=0; shift;;
      --app)         open_app="$2"; shift 2;;
      --prune-stale) prune_stale=1; shift;;
      --dry-run)     dry_run=1; shift;;
      --exact)       exact_match=1; shift;;
      --cwd)         prefer_cwd=1; shift;;
      -v|--version)
        echo "git-worktrees wtopen v${WT_VERSION:-unknown}"
        return 0;;
      *)
        if [[ -z $branch_ref ]]; then branch_ref="$1"; else echo "Unknown arg: $1"; return 2; fi
        shift;;
    esac
  done

  # -------- sanity checks --------
  if ! git rev-parse --git-dir &>/dev/null; then
    if typeset -f wt_error_not_git_repo >/dev/null 2>&1; then
      wt_error_not_git_repo
    else
      echo "❌ Not a git repository" >&2
    fi
    return 1
  fi
  
  if ! command -v fzf >/dev/null; then
    FZF_MISSING=1
  fi

  # Option: prune stale
  if (( prune_stale )); then
    echo "🧹  Pruning stale worktrees…"
    git worktree prune -v || true
    return 0
  fi

  # Fallback if wt_short_ref is not available from common lib
  if ! typeset -f wt_short_ref >/dev/null 2>&1; then
    wt_short_ref() {
      local sel="$1" short=""
      if [[ "$sel" =~ ^refs/heads/(.+)$ ]]; then
        short="${match[1]}"
      elif [[ "$sel" =~ ^refs/remotes/([^/]+)/(.+)$ ]]; then
        short="${match[2]}"
      elif [[ "$sel" =~ ^remotes/([^/]+)/(.+)$ ]]; then
        short="${match[2]}"
      else
        short="$sel"
      fi
      printf "%s" "$short"
    }
  fi

  # Normalize requested branch
  local requested_branch=""
  if [[ -n $branch_ref && $exact_match -eq 0 ]]; then
    if git remote | grep -Fxq "${branch_ref%%/*}" && [[ "$branch_ref" == */* ]]; then
      requested_branch="${branch_ref#*/}"
    else
      requested_branch="$(wt_short_ref "$branch_ref")"
    fi
  else
    requested_branch="$branch_ref"
  fi

  # -------- parse worktrees via shared helper (branch\tpath) --------
  local selectable porcelain
  porcelain="$(git worktree list --porcelain 2>/dev/null)"
  selectable="$(wt_parse_worktrees_porcelain 0 "$porcelain")"

  if [[ -n ${WT_DEBUG:-${WTOPEN_DEBUG:-}} ]]; then
    echo "DBG selectable count: $(printf "%s" "$selectable" | sed '/^$/d' | wc -l)" >&2
    printf "%s" "$selectable" >&2
  fi

  # If --list, print and exit
  if (( list_only )); then
    printf "%s" "$selectable" | awk -F"\t" '{printf "%-40s\t%s\n", $1, $2}'
    return 0
  fi

  # Find matches if branch requested (use awk for robust matching)
  local matches=""
  if [[ -n $requested_branch ]]; then
    matches="$(printf "%s\n" "$selectable" | awk -F"\t" -v b="$requested_branch" '$1==b{print $0}')"
  fi

  # If prefer_cwd and multiple matches, prefer those sharing git-common-dir
  if [[ -n $matches && $prefer_cwd -eq 1 ]]; then
    local my_common; my_common="$(git rev-parse --git-common-dir 2>/dev/null)"
    local preferred="" others=""
    local m
    local IFS=$'\n'
    for m in ${(f)matches}; do
      local mp="${m#*\t}"
      local common; common="$(git -C "$mp" rev-parse --git-common-dir 2>/dev/null || true)"
      if [[ -n "$my_common" && -n "$common" && "$common" == "$my_common" ]]; then
        preferred+="$m\n"
      else
        others+="$m\n"
      fi
    done
    if [[ -n $preferred ]]; then
      matches="$preferred"
    else
      matches="$matches"
    fi
  fi

  local target_dir="" target_branch=""

  if [[ -n $requested_branch && -n $matches && $force_fzf -eq 0 ]]; then
    # If single match, pick it; if multiple, fall back to fzf if present
    local count; count="$(printf "%s\n" "$matches" | sed '/^$/d' | wc -l | tr -d ' ')"
    if [[ "$count" == "1" ]]; then
      target_branch="$(printf "%s\n" "$matches" | awk -F"\t" 'NR==1{print $1}')"
      target_dir="$(printf "%s\n" "$matches" | awk -F"\t" 'NR==1{print $2}')"
    else
      if [[ -z $FZF_MISSING ]]; then
        local out
        out="$(printf "%s" "$matches" \
          | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
                --prompt="🔎  Pick worktree: " \
                --with-nth=1 --delimiter=$'\t' \
                --preview 'd=$(printf "%s" {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; cd "$d" && git log --oneline -n 20 --decorate --graph --color=always; fi' \
                --preview-window=right,60%)"
        [[ -z "$out" ]] && { echo "❌ No selection"; return 1; }
        target_branch="${out%%\t*}"; target_dir="${out#*\t}"
      else
        echo "❌ Multiple worktrees match '$requested_branch'. Re-run with --fzf to choose."
        return 1
      fi
    fi
  elif [[ -n $requested_branch && -z $matches && $force_fzf -eq 0 ]]; then
    echo "❌ Branch '$requested_branch' not in any worktree"
    return 1
  fi

  # If still no target and either --fzf or no branch was given, show picker of all
  if [[ -z $target_dir ]]; then
    if [[ -n $FZF_MISSING ]]; then
      echo "📝  Worktrees (branch -> dir):"
      printf "%s" "$selectable" | awk -F"\t" '{printf "- %s  \t%s\n", $1, $2}'
      printf "Pick a branch: "; read -r requested_branch
      [[ -z $requested_branch ]] && { echo "❌ No branch chosen"; return 1; }
      local found=0
      local l
      local IFS=$'\n'
      for l in ${(f)selectable}; do
        local sbr="${l%%\t*}"; local wt_path="${l#*\t}"; wt_path="${wt_path%%\t*}"
        if [[ "$sbr" == "$requested_branch" ]]; then
          target_branch="$sbr"; target_dir="$wt_path"; found=1; break
        fi
      done
      (( found )) || { echo "❌ Branch '$requested_branch' not in any worktree"; return 1; }
    else
      local out
      out="$(printf "%s" "$selectable" \
        | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
              --prompt="📂  Open worktree (type to filter): " \
              --with-nth=1 --delimiter=$'\t' \
              --preview 'd=$(printf "%s" {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; cd "$d" && git log --oneline -n 20 --decorate --graph --color=always; fi' \
              --preview-window=right,60%)"
      [[ -z "$out" ]] && { echo "❌ No selection"; return 1; }
      target_branch="${out%%\t*}"; target_dir="${out#*\t}"; target_dir="${target_dir%%\t*}"
    fi
  fi

  [[ -z $target_dir ]] && { echo "❌ Could not resolve target worktree"; return 1; }

  if (( dry_run )); then
    echo "DRY-RUN: would open $target_dir (branch $target_branch)"
    return 0
  fi

  if (( open_ide )); then
    # Detect editor if not specified
    if [[ -z "$open_app" ]]; then
      open_app="$(wt_get_editor 2>/dev/null)" || true
    fi
    
    # Skip if user chose "none"
    if [[ -z "$open_app" ]]; then
      echo "ℹ️  Worktree is at: $target_dir"
      return 0
    fi
    
    # Show selection context
    echo "✓ Opening worktree: $(basename "$target_dir")"
    echo "🚀  Opening in ${open_app}…"
    if typeset -f wt_open_in_android_studio >/dev/null 2>&1; then
      wt_open_in_android_studio "$target_dir" "$open_app"
    else
      # Only use 'studio' command if app is actually Android Studio
      if [[ "$open_app" == "Android Studio" ]] && command -v studio >/dev/null 2>&1; then
        studio "$target_dir" >/dev/null 2>&1 || true
      else
        if [[ -d "$target_dir/.idea" ]]; then
          open -a "$open_app" "$target_dir/.idea" >/dev/null 2>&1 || true
        elif [[ -f "$target_dir/settings.gradle" || -f "$target_dir/settings.gradle.kts" ]]; then
          local sg="$target_dir/settings.gradle"
          [[ -f "$target_dir/settings.gradle.kts" ]] && sg="$target_dir/settings.gradle.kts"
          open -a "$open_app" "$sg" >/dev/null 2>&1 || true
        elif [[ -f "$target_dir/build.gradle" || -f "$target_dir/build.gradle.kts" ]]; then
          local bg="$target_dir/build.gradle"
          [[ -f "$target_dir/build.gradle.kts" ]] && bg="$target_dir/build.gradle.kts"
          open -a "$open_app" "$bg" >/dev/null 2>&1 || true
        else
          open -a "$open_app" "$target_dir" >/dev/null 2>&1 || true
        fi
      fi
    fi
    echo "📂  If no window appears, open it manually via File → Open… → $target_dir"
  else
    echo "$target_dir"
  fi
}


