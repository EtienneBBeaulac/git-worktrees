# wtopen: find and open an existing Git worktree for a given branch
# Requires: git, (optional) fzf

emulate -L zsh
source "${${(%):-%x}:A:h}/lib/wt-common.zsh" || return 1

wtopen() {
  emulate -L zsh
  setopt local_options pipefail
  unsetopt xtrace verbose
  set +xv 2>/dev/null || true

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true


  local branch_ref="" open_ide=1 open_app=""
  local force_fzf=0 list_only=0 dry_run=0 prune_stale=0 exact_match=0 prefer_cwd=0
  local FZF_MISSING=

  # -------- flags (optional) --------
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        cat <<'USAGE'
Usage: wtopen [branchOrRef] [options]
  --list         List worktrees with branches and exit
  --fzf          Force interactive picker even if branch provided
  --no-open      Do not open in editor/IDE (print path only)
  --app NAME     App name to open (default: auto-detected)
  --prune-stale  Prune stale/prunable worktrees and exit
  --dry-run      Show which directory would be opened; do not open
  --exact        Require exact branch match (no shortname normalization)
  --cwd          Prefer matches from the current repo family if multiple
  -h, --help     Show help
Debug:
  - Set WT_DEBUG=1 to print internal lists.
USAGE
        return 0;;
      --list)        list_only=1; shift;;
      --fzf)         force_fzf=1; shift;;
      --no-open)     open_ide=0; shift;;
      --app)         open_app="$2"; shift 2;;
      --prune-stale) prune_stale=1; shift;;
      --dry-run)     dry_run=1; shift;;
      --exact)       exact_match=1; shift;;
      --cwd)         prefer_cwd=1; shift;;
      -v|--version)
        echo "git-worktrees wtopen v${WT_VERSION:-unknown}"
        return 0;;
      *)
        if [[ -z $branch_ref ]]; then branch_ref="$1"; else echo "Unknown arg: $1"; return 2; fi
        shift;;
    esac
  done

  # -------- sanity checks --------
  if ! wt_git_is_repo; then
    wt_error_not_git_repo
    return 1
  fi
  
  # Use centralized FZF detection
  wt_has_fzf || FZF_MISSING=1

  # Option: prune stale
  if (( prune_stale )); then
    echo "ğŸ§¹  Pruning stale worktreesâ€¦"
    git worktree prune -v || true
    return 0
  fi

  # Normalize requested branch
  local requested_branch=""
  if [[ -n $branch_ref && $exact_match -eq 0 ]]; then
    if git remote | grep -Fxq "${branch_ref%%/*}" && [[ "$branch_ref" == */* ]]; then
      requested_branch="${branch_ref#*/}"
    else
      requested_branch="$(wt_short_ref "$branch_ref")"
    fi
  else
    requested_branch="$branch_ref"
  fi

  # -------- parse worktrees via shared helper (branch\tpath) --------
  local selectable porcelain
  porcelain="$(wt_git_worktree_list_porcelain)"
  selectable="$(wt_parse_worktrees_porcelain 0 "$porcelain")"

  if [[ -n ${WT_DEBUG:-${WTOPEN_DEBUG:-}} ]]; then
    echo "DBG selectable count: $(printf "%s" "$selectable" | sed '/^$/d' | wc -l)" >&2
    printf "%s" "$selectable" >&2
  fi

  # If --list, print and exit
  if (( list_only )); then
    if [[ -z "$selectable" ]]; then
      echo "â„¹ï¸  No worktrees found."
    else
      printf "%s" "$selectable" | awk -F"\t" '{printf "%-40s\t%s\n", $1, $2}'
    fi
    return 0
  fi

  # Find matches if branch requested (use awk for robust matching)
  local matches=""
  if [[ -n $requested_branch ]]; then
    matches="$(printf "%s\n" "$selectable" | awk -F"\t" -v b="$requested_branch" '$1==b{print $0}')"
  fi

  # If prefer_cwd and multiple matches, prefer those sharing git-common-dir
  if [[ -n $matches && $prefer_cwd -eq 1 ]]; then
    local my_common; my_common="$(git rev-parse --git-common-dir 2>/dev/null)"
    local preferred="" others=""
    local m
    local IFS=$'\n'
    for m in ${(f)matches}; do
      local mp="${m#*	}"  # Note: literal tab character
      local common; common="$(git -C "$mp" rev-parse --git-common-dir 2>/dev/null || true)"
      if [[ -n "$my_common" && -n "$common" && "$common" == "$my_common" ]]; then
        preferred+="$m"$'\n'
      else
        others+="$m"$'\n'
      fi
    done
    if [[ -n $preferred ]]; then
      # Remove trailing newline for consistency
      matches="${preferred%$'\n'}"
    elif [[ -n $others ]]; then
      # No matches in current repo family, inform user and use all matches
      wt_msg_info "No matches in current repo, showing all"
      matches="${others%$'\n'}"
    fi
  fi

  local target_dir="" target_branch=""

  if [[ -n $requested_branch && -n $matches && $force_fzf -eq 0 ]]; then
    # If single match, pick it; if multiple, fall back to fzf if present
    local count; count="$(printf "%s\n" "$matches" | sed '/^$/d' | wc -l | tr -d ' ')"
    if [[ "$count" == "1" ]]; then
      target_branch="$(printf "%s\n" "$matches" | awk -F"\t" 'NR==1{print $1}')"
      target_dir="$(printf "%s\n" "$matches" | awk -F"\t" 'NR==1{print $2}')"
    else
      if [[ -z $FZF_MISSING ]]; then
        local out
        out="$(printf "%s" "$matches" \
          | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
                --prompt="ğŸ”  Pick worktree: " \
                --with-nth=1 --delimiter=$'\t' \
                --preview 'd=$(printf "%s" {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; cd "$d" && git log --oneline -n 20 --decorate --graph --color=always; fi' \
                --preview-window=right,60%)"
        [[ -z "$out" ]] && { wt_msg_error "No selection"; return 1; }
        target_branch="${out%%\t*}"; target_dir="${out#*\t}"
      else
        # FZF not installed - show the matches and let user pick manually
        wt_msg_error "Multiple worktrees match '$requested_branch':"
        echo ""
        printf "%s\n" "$matches" | awk -F"\t" '{printf "  â€¢ %s â†’ %s\n", $1, $2}'
        echo ""
        echo "ğŸ’¡ To choose interactively, install fzf:"
        echo "   brew install fzf    # macOS"
        echo "   apt install fzf     # Ubuntu/Debian"
        echo ""
        echo "   Or use a more specific branch name, or cd to the worktree directory."
        return 1
      fi
    fi
  elif [[ -n $requested_branch && -z $matches && $force_fzf -eq 0 ]]; then
    wt_msg_error "Branch '$requested_branch' not in any worktree"
    return 1
  fi

  # If still no target and either --fzf or no branch was given, show picker of all
  if [[ -z $target_dir ]]; then
    if [[ -n $FZF_MISSING ]]; then
      echo "ğŸ“  Worktrees (branch -> dir):"
      printf "%s" "$selectable" | awk -F"\t" '{printf "- %s  \t%s\n", $1, $2}'
      printf "Pick a branch: "; read -r requested_branch
      [[ -z $requested_branch ]] && { wt_msg_error "No branch chosen"; return 1; }
      local found=0
      local l
      local IFS=$'\n'
      for l in ${(f)selectable}; do
        local sbr="${l%%\t*}"; local wt_path="${l#*\t}"; wt_path="${wt_path%%\t*}"
        if [[ "$sbr" == "$requested_branch" ]]; then
          target_branch="$sbr"; target_dir="$wt_path"; found=1; break
        fi
      done
      (( found )) || { wt_msg_error "Branch '$requested_branch' not in any worktree"; return 1; }
    else
      local out
      out="$(printf "%s" "$selectable" \
        | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
              --prompt="ğŸ“‚  Open worktree (type to filter): " \
              --with-nth=1 --delimiter=$'\t' \
              --preview 'd=$(printf "%s" {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; cd "$d" && git log --oneline -n 20 --decorate --graph --color=always; fi' \
              --preview-window=right,60%)"
      [[ -z "$out" ]] && { wt_msg_error "No selection"; return 1; }
      target_branch="${out%%\t*}"; target_dir="${out#*\t}"; target_dir="${target_dir%%\t*}"
    fi
  fi

  [[ -z $target_dir ]] && { wt_msg_error "Could not resolve target worktree"; return 1; }

  if (( dry_run )); then
    echo "DRY-RUN: would open $target_dir (branch $target_branch)"
    return 0
  fi

  if (( open_ide )); then
    # Detect editor if not specified
    if [[ -z "$open_app" ]]; then
      open_app="$(wt_get_editor 2>/dev/null)" || true
    fi
    
    # Skip if user chose "none"
    if [[ -z "$open_app" ]]; then
      echo "â„¹ï¸  Worktree is at: $target_dir"
      return 0
    fi
    
    # Show selection context
    echo "âœ“ Opening worktree: $(basename "$target_dir")"
    echo "ğŸš€  Opening in ${open_app}â€¦"
    wt_open_in_editor "$target_dir" "$open_app"
    echo "ğŸ“‚  If no window appears, open it manually via File â†’ Openâ€¦ â†’ $target_dir"
  else
    echo "$target_dir"
  fi
}


