# wt: hub for listing and acting on Git worktrees
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WT__SCRIPT_FILE WT__SCRIPT_DIR WT__COMMON_LIB
WT__SCRIPT_FILE=${(%):-%N}
if [[ -n $WT__SCRIPT_FILE && -f $WT__SCRIPT_FILE ]]; then
  WT__SCRIPT_DIR="${WT__SCRIPT_FILE:A:h}"
else
  WT__SCRIPT_DIR="${0:A:h}"
fi
WT__COMMON_LIB="${WT__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WT__COMMON_LIB" ]] && source "$WT__COMMON_LIB" || true
wt() {
  emulate -L zsh
  setopt local_options pipefail
  unsetopt xtrace verbose
  set +xv 2>/dev/null || true

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true

  # ============================================================================
  # Subcommand Dispatch (Phase 2 - v1.1.0)
  # ============================================================================
  
  # Special case: --tutorial flag (show interactive tutorial)
  if [[ "$1" == "--tutorial" ]]; then
    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            Welcome to git-worktrees! (1/4)                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

What are worktrees?
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Git worktrees let you check out multiple branches at once.

Instead of constantly switching branches:
  $ git checkout feature
  $ git checkout main
  $ git checkout bugfix

You have separate directories:
  ~/code/repo/          ‚Üí main branch
  ~/code/repo-feature/  ‚Üí feature branch
  ~/code/repo-bugfix/   ‚Üí bugfix branch

All active at the same time! üéâ

Benefits:
  ‚úì No need to stash/unstash
  ‚úì Work on multiple features simultaneously
  ‚úì Keep builds running while you code
  ‚úì Compare branches side-by-side

TUTORIAL
    printf "\nPress Enter to continue, or 'q' to quit... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               Creating Worktrees (2/4)                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

To create your first worktree:

  $ wt new feature-branch

This will:
  1. Create branch 'feature-branch' (if it doesn't exist)
  2. Create directory '../repo-feature-branch/'
  3. Check out the branch there
  4. Open in your editor (auto-detected)

Advanced options:
  $ wt new feature -b main       # Create from 'main' branch
  $ wt new feature --no-open     # Don't open editor
  $ wt new feature --push        # Also push to remote

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              Managing Worktrees (3/4)                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Key commands:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wt                # Interactive hub (fuzzy find)
  wt new <name>     # Create worktree
  wt open <name>    # Open existing worktree
  wt remove         # Remove worktree (safe, with checks)
  wt list           # Show all worktrees with status

Keyboard shortcuts in 'wt' hub:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Enter   ‚Üí Open selected worktree
  Ctrl-N  ‚Üí Create new worktree
  Ctrl-D  ‚Üí Remove worktree
  Ctrl-A  ‚Üí Actions menu
  Ctrl-P  ‚Üí Prune stale worktrees
  Ctrl-H  ‚Üí Show help

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                 You're Ready! (4/4)                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Quick start workflow:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  1. Run 'wt new my-feature' to create your first worktree
  2. Work in the new worktree directory
  3. Run 'wt' anytime to switch between worktrees
  4. Use 'wt remove' when you're done with a branch

Tips:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Each worktree is independent - changes don't affect others
  ‚Ä¢ You can have multiple IDE windows open, one per worktree
  ‚Ä¢ Worktrees share the same .git database (efficient!)
  ‚Ä¢ Great for reviewing PRs while keeping your work intact

More help:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wt help           # Full documentation
  wt new --help     # Command-specific help
  wt remove --help  # More options

Happy coding! ‚ú®

TUTORIAL
    return 0
  fi
  
  # Check if first arg is a subcommand (git-style: wt new, wt remove, etc.)
  if [[ $# -gt 0 ]]; then
    case "$1" in
      new|n)
        shift
        if command -v wtnew >/dev/null 2>&1; then
          wtnew "$@"
          return $?
        else
          echo "‚ùå wtnew command not found"; return 1
        fi
        ;;
      remove|rm)
        shift
        if command -v wtrm >/dev/null 2>&1; then
          wtrm "$@"
          return $?
        else
          echo "‚ùå wtrm command not found"; return 1
        fi
        ;;
      open|o)
        shift
        if command -v wtopen >/dev/null 2>&1; then
          wtopen "$@"
          return $?
        else
          echo "‚ùå wtopen command not found"; return 1
        fi
        ;;
      list|ls)
        shift
        if command -v wtls >/dev/null 2>&1; then
          wtls "$@"
          return $?
        else
          echo "‚ùå wtls command not found"; return 1
        fi
        ;;
      prune)
        shift
        if command -v wtrm >/dev/null 2>&1; then
          wtrm --prune-only "$@"
          return $?
        else
          git worktree prune -v
          return $?
        fi
        ;;
      config)
        shift
        local action="${1:-show}"
        case "$action" in
          init)
            if typeset -f wt_init_config >/dev/null 2>&1; then
              wt_init_config
            else
              echo "‚ùå Config initialization not available"
              return 1
            fi
            ;;
          edit)
            local config_file="${HOME}/.config/git-worktrees/config"
            if [[ ! -f "$config_file" ]]; then
              echo "‚ö†Ô∏è  Config file doesn't exist. Creating it..."
              if typeset -f wt_init_config >/dev/null 2>&1; then
                wt_init_config
              fi
            fi
            local editor="${EDITOR:-${VISUAL:-vim}}"
            "$editor" "$config_file"
            ;;
          set)
            local config_file="${HOME}/.config/git-worktrees/config"
            local key="$2"
            local value="$3"
            if [[ -z "$key" || -z "$value" ]]; then
              echo "Usage: wt config set <key> <value>"
              echo ""
              echo "Common keys:"
              echo "  editor                    - Default editor (e.g., \"Cursor\")"
              echo "  behavior.autoopen         - Auto-open in editor (true/false)"
              echo "  behavior.editor_prompt    - When to prompt (silent/always/first-time)"
              return 1
            fi
            
            # Create config if missing
            if [[ ! -f "$config_file" ]]; then
              if typeset -f wt_init_config >/dev/null 2>&1; then
                wt_init_config >/dev/null 2>&1
              else
                mkdir -p "$(dirname "$config_file")"
                cat > "$config_file" <<EOF
# git-worktrees configuration
editor=
behavior.autoopen=true
behavior.editor_prompt=silent
EOF
              fi
            fi
            
            # Update or append the value
            if grep -q "^${key}=" "$config_file" 2>/dev/null; then
              wt_sed_i "s|^${key}=.*|${key}=${value}|" "$config_file"
              echo "‚úÖ Updated: ${key}=${value}"
            else
              echo "${key}=${value}" >> "$config_file"
              echo "‚úÖ Added: ${key}=${value}"
            fi
            ;;
          get)
            local config_file="${HOME}/.config/git-worktrees/config"
            local key="$2"
            if [[ -z "$key" ]]; then
              echo "Usage: wt config get <key>"
              echo ""
              echo "Example: wt config get editor"
              return 1
            fi
            
            if [[ ! -f "$config_file" ]]; then
              echo "No config file found."
              return 1
            fi
            
            local value
            value="$(grep "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)"
            if [[ -n "$value" ]]; then
              echo "$value"
            else
              echo "Key not found: $key" >&2
              return 1
            fi
            ;;
          show|path)
            local config_file="${HOME}/.config/git-worktrees/config"
            if [[ -f "$config_file" ]]; then
              echo "Config file: $config_file"
              echo ""
              cat "$config_file"
            else
              echo "No config file found."
              echo "Run 'wt config init' to create one."
            fi
            ;;
          *)
            cat <<'CONFIGHELP'
Usage: wt config <action>

Actions:
  show         Show current config (default)
  edit         Edit config in $EDITOR
  init         Initialize config with defaults
  set KEY VAL  Set a config value
  get KEY      Get a config value
  path         Show config file path

Config file location: ~/.config/git-worktrees/config

Common keys:
  editor                    - Default editor (e.g., "Cursor")
  behavior.autoopen         - Auto-open in editor (true/false)
  behavior.editor_prompt    - When to prompt (silent/always/first-time)

Examples:
  wt config                           # Show current config
  wt config edit                      # Edit in your editor
  wt config set editor "Cursor"       # Set default editor
  wt config get editor                # Get current editor
CONFIGHELP
            ;;
        esac
        return 0
        ;;
      help|h)
        # Show comprehensive help with subcommands
        cat <<'HELP'
git-worktrees - Manage Git worktrees with ease

Usage:
  wt [options]                 Interactive worktree hub (fuzzy find)
  wt <branch>                  Quick open/create worktree for branch
  wt <subcommand> [args]       Run subcommand

Subcommands:
  new, n       Create/open worktree for a branch
  open, o      Open existing worktree
  remove, rm   Remove worktree safely
  list, ls     List all worktrees with status
  prune        Remove stale worktree references
  config       Manage configuration
  help, h      Show this help

Hub Options:
  --start list|new             Start in list or branch-first mode
  --detached                   Include detached worktrees
  --enter-default open|menu    Default Enter key behavior
  -v, --version                Show version
  -h, --help                   Show help

Examples:
  wt                          # Interactive hub
  wt feature                  # Quick open 'feature' branch
  wt new feature              # Create worktree for 'feature'
  wt new feature -b main      # Create from 'main' branch
  wt remove                   # Interactive removal
  wt list                     # List all worktrees

For command-specific help:
  wt new --help
  wt remove --help
  wt open --help
  wt list --help

Documentation: https://github.com/EtienneBBeaulac/git-worktrees
HELP
        return 0
        ;;
      # Not a subcommand - continue with existing logic
      -*|--*)
        # It's a flag, process normally below
        ;;
      *)
        # Could be a branch name, process normally below
        ;;
    esac
  fi

  # ============================================================================
  # Original Hub Logic (Interactive Mode / Branch Fast Path)
  # ============================================================================
  
  local start_mode="list" include_detached=0 enter_default="${WTHUB_ENTER_DEFAULT:-}"
  local branch_arg="" FZF_MISSING=

  # Centralized config: prefer runtime env/flags; fall back to config
  typeset -gA WT_CONFIG
  typeset cfg_file_hub
  wt_load_config 2>/dev/null || true
  enter_default="${enter_default:-${WTHUB_ENTER_DEFAULT:-}}"
  if [[ -z ${enter_default:-} ]]; then
    # Back-compat: also read historical hub file if present
    cfg_file_hub="$HOME/.config/git-worktrees/hub"
    if [[ -f "$cfg_file_hub" ]]; then
      enter_default="$(awk -F'=' '/^ENTER_DEFAULT=/{print $2}' "$cfg_file_hub" | tail -n1)"
    else
      enter_default="$(wt_get_config WT_ENTER_BEHAVIOR open)"
    fi
  fi
  [[ -z ${enter_default:-} ]] && enter_default="open"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --start)
        start_mode="$2"; shift 2;;
      --detached)
        include_detached=1; shift;;
      --enter-default)
        enter_default="$2"; shift 2;;
      -v|--version)
        echo "git-worktrees wt v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wt [options] [branch]
       wt <subcommand> [args]

Subcommands:
  new, n       Create/open worktree (same as wtnew)
  remove, rm   Remove worktree (same as wtrm)
  open, o      Open worktree (same as wtopen)
  list, ls     List worktrees (same as wtls)
  prune        Remove stale references
  config       Manage configuration (edit, show, init)
  help         Show detailed help

Hub Options:
  --start list|new        Start in list-first or branch-first mode (default: list)
  --detached              Include detached/headless worktrees in list
  --enter-default open|menu  Default Enter behavior (default: open)
  -v, --version           Show version
  -h, --help              Show this help

Examples:
  wt                      Interactive hub
  wt feature              Quick open/create 'feature' branch
  wt new feature          Create worktree for 'feature'

For detailed help: wt help
USAGE
        return 0;;
      --*) echo "Unknown option: $1"; return 2;;
      *) branch_arg="$1"; shift;;
    esac
  done

  if ! git rev-parse --git-dir &>/dev/null; then
    if typeset -f wt_error_not_git_repo >/dev/null 2>&1; then
      wt_error_not_git_repo
    else
      echo "‚ùå Not a git repository" >&2
    fi
    return 1
  fi
  
  if ! command -v fzf >/dev/null; then
    FZF_MISSING=1
    if typeset -f wt_error_fzf_missing >/dev/null 2>&1; then
      wt_error_fzf_missing
    fi
  fi

  # Fast path: wt <branch> auto-resolve
  if [[ -n $branch_arg ]]; then
    local br_short="$branch_arg" existing_dir=""
    # Strip remote prefix if present
    if git remote | grep -Fxq "${br_short%%/*}" && [[ "$br_short" == */* ]]; then
      br_short="${br_short#*/}"
    fi
    # Use common porcelain parser to resolve existing worktree path for branch
    local porcelain rows
    porcelain="$(git worktree list --porcelain 2>/dev/null)"
    rows="$(wt_parse_worktrees_porcelain 0 "$porcelain")"
    existing_dir="$(printf "%s\n" "$rows" | awk -F"\t" -v b="$br_short" '$1==b{print $2; exit}')"
    if [[ -n $existing_dir && -d $existing_dir ]]; then
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        echo "üöÄ  Opening in ${detected_app}‚Ä¶"
        if typeset -f wt_open_in_android_studio >/dev/null 2>&1; then
          wt_open_in_android_studio "$existing_dir" "$detected_app"
        else
          open -a "$detected_app" "$existing_dir" >/dev/null 2>&1 || true
        fi
      else
        echo "‚ÑπÔ∏è  Worktree is at: $existing_dir"
      fi
      return 0
    else
      # Fallback to wtnew for creation
      if command -v wtnew >/dev/null 2>&1; then
        wtnew -n "$br_short"
        return $?
      else
        echo "‚ÑπÔ∏è  No existing worktree for '$br_short'. Install wtnew to create."; return 1
      fi
    fi
  fi

  # Branch-first start (reuse wtnew)
  if [[ "$start_mode" == "new" ]]; then
    if command -v wtnew >/dev/null 2>&1; then
      wtnew
      return $?
    else
      echo "‚ùå wtnew not available"; return 1
    fi
  fi

  # Build list (branch\tpath). Detached hidden by default.
  local selectable porcelain
  porcelain="$(git worktree list --porcelain 2>/dev/null)"
  selectable="$(wt_parse_worktrees_porcelain ${include_detached} "$porcelain")"

  # ============================================================================
  # First-Run Experience (Phase 2 - v1.1.0)
  # ============================================================================
  # Check if this looks like a first run (only 1 worktree = main repo)
  local worktree_count
  worktree_count=$(printf "%s" "$selectable" | sed '/^$/d' | wc -l | tr -d ' ')
  
  if [[ "$worktree_count" -eq 1 ]]; then
    cat <<'FIRSTRUN'

üìÇ No additional worktrees found.

üí° What are worktrees?
   Git worktrees let you work on multiple branches simultaneously.
   Each worktree is a separate directory with its own checked-out branch.

   Instead of: git checkout feature ‚Üí git checkout main ‚Üí git checkout bugfix
   You can have: ~/repo-feature/, ~/repo-main/, ~/repo-bugfix/
   All at once! ‚ú®

üöÄ Get started:
   wt new <branch-name>    # Create your first worktree
   wt new feature -b main  # Create from specific base branch
   
üìñ Learn more:
   wt --tutorial           # Interactive tutorial
   wt help                 # Full documentation

FIRSTRUN
    return 0
  fi

  # Prepend New branch row
  selectable="‚ûï New branch‚Ä¶"$'\t'$'(create)'$'\n'"$selectable"
  if (( ! include_detached )); then
    selectable="üßµ Show detached‚Ä¶"$'\t'$'(toggle)'$'\n'"$selectable"
  fi

  wt_debug "wt selectable count: $(printf "%s" "$selectable" | sed '/^$/d' | wc -l)"
  wt_debug "selectable START"
  if [[ -n ${WT_DEBUG:-} ]]; then printf "%s\n" "$selectable" >&2; fi
  wt_debug "selectable END"

  if [[ -n $FZF_MISSING ]]; then
    echo "üìù  Worktrees (branch -> dir):"
    printf "%s" "$selectable" | awk -F"\t" '{printf "- %s  \t%s\n", $1, $2}'
    printf "Pick a branch or 'New branch‚Ä¶': "; local sel; read -r sel
    [[ -z $sel ]] && { echo "‚ùå No selection"; return 1; }
    if [[ "$sel" == "‚ûï New branch"* ]]; then
      if command -v wtnew >/dev/null 2>&1; then
        wtnew
      else
        echo "‚ùå wtnew not available"
      fi
      return $?
    elif [[ "$sel" == "üßµ Show detached"* ]]; then
      wt --detached --start list; return $?
    else
      local path; path="$(printf "%s" "$selectable" | awk -F"\t" -v b="$sel" '$1==b{print $2; exit}')"
      [[ -z $path ]] && { echo "‚ùå Unknown selection"; return 1; }
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$path" "$detected_app" \
          || open -a "$detected_app" "$path" >/dev/null 2>&1 || true
      else
        echo "‚ÑπÔ∏è  Worktree is at: $path"
      fi
      return 0
    fi
  fi

  local out key line
  local header="Enter=open ‚îÇ ^N=new ‚îÇ ^D=remove ‚îÇ ^A=actions ‚îÇ ^P=prune ‚îÇ ^E=toggle-enter ‚îÇ ^H=help"
  out="$(printf "%s" "$selectable" | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} --prompt='üìÇ  Worktrees: ' --header="$header" --with-nth=1 --delimiter=$'\t' --expect=enter,ctrl-o,ctrl-d,ctrl-p,ctrl-n,ctrl-r,ctrl-a,ctrl-e,ctrl-h --preview 'd=$(printf %s {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; git -C "$d" status -sb --untracked-files=all 2>/dev/null; echo; git -C "$d" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null; fi' --preview-window=right,60%)" || true

  key="$(printf "%s" "$out" | head -n1)"
  line="$(printf "%s" "$out" | sed -n '2p')"
  [[ -z $line ]] && { echo "‚ùå No selection"; return 1; }

  local sel_branch sel_path tab
  tab=$'\t'
  sel_branch="${line%%${tab}*}"; sel_path="${line#*${tab}}"; sel_path="${sel_path%%${tab}*}"
  
  # Echo selection for context
  if [[ "$sel_branch" == "‚ûï New branch‚Ä¶" ]]; then
    echo "‚úì Creating new worktree"
  elif [[ "$sel_branch" == "üßµ Show detached‚Ä¶" ]]; then
    echo "‚úì Toggling detached worktrees"
  else
    echo "‚úì Selected: $sel_branch"
  fi
  
  wt_debug "key=[$key] line=[$line] sel_branch=[$sel_branch] sel_path=[$sel_path]"

  # New branch row
  if [[ "$sel_branch" == "‚ûï New branch"* ]]; then
    command -v wtnew >/dev/null 2>&1 && wtnew || echo "‚ùå wtnew not available"
    return $?
  fi

  # Show detached toggle row
  if [[ "$sel_branch" == "üßµ Show detached"* || "$sel_path" == "(toggle)" ]]; then
    include_detached=1; wt --detached --start list "$@"; return $?
  fi

  # Map keys
  case "${key:-enter}" in
    enter|ctrl-o)
      if [[ "$enter_default" == "menu" ]]; then
        # Open actions menu instead of opening directly
        local outa
        outa="$(printf "%s\n" "Open" "Show path" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="‚öôÔ∏è  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$outa" in
          ("Open")
            local detected_app
            detected_app="$(wt_get_editor 2>/dev/null)" || true
            if [[ -n "$detected_app" ]]; then
              typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
                && wt_open_in_android_studio "$sel_path" "$detected_app" \
                || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
            else
              echo "‚ÑπÔ∏è  Worktree is at: $sel_path"
            fi;;
          ("Show path") echo "$sel_path";;
          ("Remove") command -v wtrm >/dev/null 2>&1 && wtrm -d "$sel_path" || echo "‚ùå wtrm not available";;
          ("Remove all detached") command -v wtrm >/dev/null 2>&1 && wtrm --rm-detached || echo "‚ùå wtrm not available";;
          ("Prune stale") command -v wtrm >/dev/null 2>&1 && wtrm --prune-only || git worktree prune -v;;
          ("Set upstream (origin)")
            local b="${sel_branch}"; local remote="origin"
            if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
              git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "‚úÖ Upstream: $remote/$b" || echo "‚ùå Failed to set upstream"
            else
              echo "‚ÑπÔ∏è  Remote $remote/$b not found. Trying push -u‚Ä¶"
              git -C "$sel_path" push -u "$remote" "$b" || echo "‚ùå Push failed"
            fi;;
        esac
        return 0
      fi
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$sel_path" "$detected_app" \
          || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
      else
        echo "‚ÑπÔ∏è  Worktree is at: $sel_path"
      fi
      ;;
    ctrl-d)
      if command -v wtrm >/dev/null 2>&1; then
        wtrm -d "$sel_path"
      else
        echo "‚ùå wtrm not available"
      fi
      ;;
    ctrl-p)
      if command -v wtrm >/dev/null 2>&1; then
        wtrm --prune-only
      else
        git worktree prune -v || true
      fi
      ;;
    ctrl-n)
      if command -v wtnew >/dev/null 2>&1; then
        # Choose creation mode
        local mode
        mode="$(printf "%s\n" "Create (smart reuse)" "Create (force reuse)" "Create (new dir)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="‚ûï New: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$mode" in
          ("Create (force reuse)") wtnew --prefer-reuse;;
          ("Create (new dir)") WTNEW_PREFER_REUSE= wtnew;;
          (*) wtnew;;
        esac
      else
        echo "‚ùå wtnew not available"
      fi
      ;;
    ctrl-r)
      if command -v wtnew >/dev/null 2>&1; then
        wtnew --prefer-reuse
      else
        echo "‚ùå wtnew not available"
      fi
      ;;
    ctrl-a)
      # Simple actions menu
      local act outa
      outa="$(printf "%s\n" "Open" "Show path" "Copy path" "Open in terminal" "Print cd command" "Change editor" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
        | FZF_DEFAULT_OPTS= command fzf --prompt="‚öôÔ∏è  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$outa" in
        ("Open")
          local detected_app
          detected_app="$(wt_get_editor 2>/dev/null)" || true
          if [[ -n "$detected_app" ]]; then
            typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
              && wt_open_in_android_studio "$sel_path" "$detected_app" \
              || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
          else
            echo "‚ÑπÔ∏è  Worktree is at: $sel_path"
          fi;;
        ("Show path") echo "$sel_path";;
        ("Copy path")
          if command -v pbcopy >/dev/null 2>&1; then
            printf "%s" "$sel_path" | pbcopy && echo "üìã Copied: $sel_path"
          else
            echo "$sel_path"
          fi;;
        ("Open in terminal")
          local term_app="${WT_TERMINAL_APP:-iTerm}"
          open -a "$term_app" "$sel_path" >/dev/null 2>&1 || open -a Terminal "$sel_path" >/dev/null 2>&1 || echo "‚ùå Could not open terminal";;
        ("Print cd command")
          echo "cd '$sel_path'";;
        ("Change editor")
          echo ""
          echo "üìÇ Choose your default editor:"
          echo "  1) Android Studio"
          echo "  2) Visual Studio Code"
          echo "  3) Cursor"
          echo "  4) IntelliJ IDEA"
          echo "  5) PyCharm"
          echo "  6) WebStorm"
          echo "  7) Sublime Text"
          echo "  8) vim"
          echo "  9) Don't auto-open (show path only)"
          echo ""
          printf "Choice [1-9]: "
          local choice
          read -r choice
          
          local selected=""
          case "$choice" in
            1) selected="Android Studio" ;;
            2) selected="Visual Studio Code" ;;
            3) selected="Cursor" ;;
            4) selected="IntelliJ IDEA" ;;
            5) selected="PyCharm" ;;
            6) selected="WebStorm" ;;
            7) selected="Sublime Text" ;;
            8) selected="vim" ;;
            9) selected="none" ;;
            *) 
              echo "‚ö†Ô∏è  Invalid choice"
              return 1
              ;;
          esac
          
          # Save to config
          local config_file="${HOME}/.config/git-worktrees/config"
          mkdir -p "$(dirname "$config_file")"
          if [[ ! -f "$config_file" ]]; then
            if typeset -f wt_init_config >/dev/null 2>&1; then
              wt_init_config >/dev/null 2>&1
            fi
          fi
          
          if [[ -f "$config_file" ]]; then
            if grep -q "^editor=" "$config_file" 2>/dev/null; then
              wt_sed_i "s|^editor=.*|editor=${selected}|" "$config_file"
            else
              echo "editor=${selected}" >> "$config_file"
            fi
          else
            echo "editor=${selected}" > "$config_file"
          fi
          
          if [[ "$selected" == "none" ]]; then
            echo "‚úÖ Configured: Show path only (no auto-open)"
          else
            echo "‚úÖ Saved: $selected"
          fi
          ;;
        ("Remove") command -v wtrm >/dev/null 2>&1 && wtrm -d "$sel_path" || echo "‚ùå wtrm not available";;
        ("Remove all detached") command -v wtrm >/dev/null 2>&1 && wtrm --rm-detached || echo "‚ùå wtrm not available";;
        ("Prune stale") command -v wtrm >/dev/null 2>&1 && wtrm --prune-only || git worktree prune -v;;
        ("Set upstream (origin)")
          local b="${sel_branch}"; local remote="origin"
          if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
            git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "‚úÖ Upstream: $remote/$b" || echo "‚ùå Failed to set upstream"
          else
            echo "‚ÑπÔ∏è  Remote $remote/$b not found. Trying push -u‚Ä¶"
            git -C "$sel_path" push -u "$remote" "$b" || echo "‚ùå Push failed"
          fi;;
      esac
      ;;
    ctrl-e)
      # Toggle Enter default between open and menu, then re-run hub with same view
      if [[ "$enter_default" == "open" ]]; then
        local cfg_dir; cfg_dir="$HOME/.config/git-worktrees"; local cfg_file; cfg_file="$cfg_dir/hub"
        mkdir -p "$cfg_dir" 2>/dev/null || true
        { printf "%s\n" "ENTER_DEFAULT=menu"; } > "$cfg_file" 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=menu wt ${include_detached:+--detached} --start list
      else
        local cfg_dir; cfg_dir="$HOME/.config/git-worktrees"; local cfg_file; cfg_file="$cfg_dir/hub"
        mkdir -p "$cfg_dir" 2>/dev/null || true
        { printf "%s\n" "ENTER_DEFAULT=open"; } > "$cfg_file" 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=open wt ${include_detached:+--detached} --start list
      fi
      return $?
      ;;
    ctrl-h)
      cat <<HELP
wt hub
  Enter: ${enter_default}   (Ctrl-E toggles)
  Keys:  Ctrl-N new   Ctrl-R new (reuse)   Ctrl-D remove   Ctrl-P prune   Ctrl-A actions   Ctrl-O open   Ctrl-H help
  Rows:  "‚ûï New branch‚Ä¶" starts branch-first flow; "üßµ Show detached‚Ä¶" toggles headless entries
HELP
      ;;
    *)
      # Default fallback: open
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$sel_path" "$detected_app" \
          || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
      else
        echo "‚ÑπÔ∏è  Worktree is at: $sel_path"
      fi
      ;;
  esac
}


