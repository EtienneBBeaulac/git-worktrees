# wt: hub for listing and acting on Git worktrees
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WT__SCRIPT_FILE WT__SCRIPT_DIR WT__COMMON_LIB
WT__SCRIPT_FILE=${(%):-%N}
if [[ -n $WT__SCRIPT_FILE && -f $WT__SCRIPT_FILE ]]; then
  WT__SCRIPT_DIR="${WT__SCRIPT_FILE:A:h}"
else
  WT__SCRIPT_DIR="${0:A:h}"
fi
WT__COMMON_LIB="${WT__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WT__COMMON_LIB" ]] && source "$WT__COMMON_LIB" || true
wt() {
  emulate -L zsh
  setopt local_options pipefail
  unsetopt xtrace verbose
  set +xv 2>/dev/null || true

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true

  # ============================================================================
  # Subcommand Dispatch (Phase 2 - v1.1.0)
  # ============================================================================
  
  # Special case: --tutorial flag (show interactive tutorial)
  if [[ "$1" == "--tutorial" ]]; then
    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            Welcome to git-worktrees! (1/4)                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

What are worktrees?
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Git worktrees let you check out multiple branches at once.

Instead of constantly switching branches:
  $ git checkout feature
  $ git checkout main
  $ git checkout bugfix

You have separate directories:
  ~/code/repo/          ‚Üí main branch
  ~/code/repo-feature/  ‚Üí feature branch
  ~/code/repo-bugfix/   ‚Üí bugfix branch

All active at the same time! üéâ

Benefits:
  ‚úì No need to stash/unstash
  ‚úì Work on multiple features simultaneously
  ‚úì Keep builds running while you code
  ‚úì Compare branches side-by-side

TUTORIAL
    printf "\nPress Enter to continue, or 'q' to quit... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               Creating Worktrees (2/4)                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

To create your first worktree:

  $ wt new feature-branch

This will:
  1. Create branch 'feature-branch' (if it doesn't exist)
  2. Create directory '../repo-feature-branch/'
  3. Check out the branch there
  4. Open in your editor (auto-detected)

Advanced options:
  $ wt new feature -b main       # Create from 'main' branch
  $ wt new feature --no-open     # Don't open editor
  $ wt new feature --push        # Also push to remote

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              Managing Worktrees (3/4)                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Key commands:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wt                # Interactive hub (fuzzy find)
  wt new <name>     # Create worktree
  wt open <name>    # Open existing worktree
  wt remove         # Remove worktree (safe, with checks)
  wt list           # Show all worktrees with status

Keyboard shortcuts in 'wt' hub:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Enter   ‚Üí Open selected worktree
  Ctrl-N  ‚Üí Create new worktree
  Ctrl-D  ‚Üí Remove worktree
  Ctrl-A  ‚Üí Actions menu
  Ctrl-P  ‚Üí Prune stale worktrees
  Ctrl-H  ‚Üí Show help

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                 You're Ready! (4/4)                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Quick start workflow:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  1. Run 'wt new my-feature' to create your first worktree
  2. Work in the new worktree directory
  3. Run 'wt' anytime to switch between worktrees
  4. Use 'wt remove' when you're done with a branch

Tips:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Each worktree is independent - changes don't affect others
  ‚Ä¢ You can have multiple IDE windows open, one per worktree
  ‚Ä¢ Worktrees share the same .git database (efficient!)
  ‚Ä¢ Great for reviewing PRs while keeping your work intact

More help:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wt help           # Full documentation
  wt new --help     # Command-specific help
  wt remove --help  # More options

Happy coding! ‚ú®

TUTORIAL
    return 0
  fi
  
  # Check if first arg is a subcommand (git-style: wt new, wt remove, etc.)
  if [[ $# -gt 0 ]]; then
    case "$1" in
      new|n)
        shift
        wt_run wtnew "$@"; return $?
        ;;
      remove|rm)
        shift
        wt_run wtrm "$@"; return $?
        ;;
      open|o)
        shift
        wt_run wtopen "$@"; return $?
        ;;
      list|ls)
        shift
        wt_run wtls "$@"; return $?
        ;;
      prune)
        shift
        if wt_has_cmd wtrm; then
          wtrm --prune-only "$@"; return $?
        else
          git worktree prune -v; return $?
        fi
        ;;
      config)
        shift
        local action="${1:-show}"
        case "$action" in
          init)
            wt_init_config
            ;;
          edit)
            local config_file="$(wt_config_file)"
            if [[ ! -f "$config_file" ]]; then
              echo "‚ö†Ô∏è  Config file doesn't exist. Creating it..."
              wt_init_config
            fi
            local editor="${EDITOR:-${VISUAL:-vim}}"
            "$editor" "$config_file"
            ;;
          set)
            local key="$2"
            local value="$3"
            if [[ -z "$key" || -z "$value" ]]; then
              echo "Usage: wt config set <key> <value>"
              echo ""
              echo "Common keys:"
              echo "  editor                    - Default editor (e.g., \"Cursor\")"
              echo "  behavior.autoopen         - Auto-open in editor (true/false)"
              echo "  behavior.editor_prompt    - When to prompt (silent/always/first-time)"
              return 1
            fi
            
            # Create config if missing
            local config_file="$(wt_config_file)"
            if [[ ! -f "$config_file" ]]; then
              wt_init_config >/dev/null 2>&1
            fi
            
            # Use wt_set_config which handles special characters safely
            wt_set_config "$key" "$value"
            echo "‚úÖ Set: ${key}=${value}"
            ;;
          get)
            local config_file="$(wt_config_file)"
            local key="$2"
            if [[ -z "$key" ]]; then
              echo "Usage: wt config get <key>"
              echo ""
              echo "Example: wt config get editor"
              return 1
            fi
            
            if [[ ! -f "$config_file" ]]; then
              echo "No config file found."
              return 1
            fi
            
            local value
            value="$(grep "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)"
            if [[ -n "$value" ]]; then
              echo "$value"
            else
              echo "Key not found: $key" >&2
              return 1
            fi
            ;;
          show|path)
            local config_file="$(wt_config_file)"
            if [[ -f "$config_file" ]]; then
              echo "Config file: $config_file"
              echo ""
              cat "$config_file"
            else
              echo "No config file found."
              echo "Run 'wt config init' to create one."
            fi
            ;;
          *)
            cat <<'CONFIGHELP'
Usage: wt config <action>

Actions:
  show         Show current config (default)
  edit         Edit config in $EDITOR
  init         Initialize config with defaults
  set KEY VAL  Set a config value
  get KEY      Get a config value
  path         Show config file path

Config file location: ~/.config/git-worktrees/config

Common keys:
  editor                    - Default editor (e.g., "Cursor")
  behavior.autoopen         - Auto-open in editor (true/false)
  behavior.editor_prompt    - When to prompt (silent/always/first-time)

Examples:
  wt config                           # Show current config
  wt config edit                      # Edit in your editor
  wt config set editor "Cursor"       # Set default editor
  wt config get editor                # Get current editor
CONFIGHELP
            ;;
        esac
        return 0
        ;;
      help|h)
        # Show comprehensive help with subcommands
        cat <<'HELP'
git-worktrees - Manage Git worktrees with ease

Usage:
  wt [options]                 Interactive worktree hub (fuzzy find)
  wt <branch>                  Quick open/create worktree for branch
  wt <subcommand> [args]       Run subcommand

Subcommands:
  new, n       Create/open worktree for a branch
  open, o      Open existing worktree
  remove, rm   Remove worktree safely
  list, ls     List all worktrees with status
  prune        Remove stale worktree references
  config       Manage configuration
  help, h      Show this help

Hub Options:
  --start list|new             Start in list or branch-first mode
  --detached                   Include detached worktrees
  --enter-default open|menu    Default Enter key behavior
  -v, --version                Show version
  -h, --help                   Show help

Examples:
  wt                          # Interactive hub
  wt feature                  # Quick open 'feature' branch
  wt new feature              # Create worktree for 'feature'
  wt new feature -b main      # Create from 'main' branch
  wt remove                   # Interactive removal
  wt list                     # List all worktrees

For command-specific help:
  wt new --help
  wt remove --help
  wt open --help
  wt list --help

Documentation: https://github.com/EtienneBBeaulac/git-worktrees
HELP
        return 0
        ;;
      # Not a subcommand - continue with existing logic
      -*|--*)
        # It's a flag, process normally below
        ;;
      *)
        # Could be a branch name, process normally below
        ;;
    esac
  fi

  # ============================================================================
  # Original Hub Logic (Interactive Mode / Branch Fast Path)
  # ============================================================================
  
  local start_mode="list" include_detached=0 enter_default="${WTHUB_ENTER_DEFAULT:-}"
  local branch_arg="" FZF_MISSING=

  # Centralized config: prefer runtime env/flags; fall back to config
  typeset -gA WT_CONFIG
  wt_load_config 2>/dev/null || true
  enter_default="${enter_default:-${WTHUB_ENTER_DEFAULT:-}}"
  if [[ -z ${enter_default:-} ]]; then
    # Check main config first
    enter_default="$(wt_get_config WT_ENTER_BEHAVIOR "")"
    # Back-compat: migrate from historical hub file if present
    if [[ -z "$enter_default" ]]; then
      local cfg_file_hub="$HOME/.config/git-worktrees/hub"
      if [[ -f "$cfg_file_hub" ]]; then
        enter_default="$(awk -F'=' '/^ENTER_DEFAULT=/{print $2}' "$cfg_file_hub" | tail -n1)"
        # Migrate to main config and remove old file
        if [[ -n "$enter_default" ]]; then
          wt_set_config WT_ENTER_BEHAVIOR "$enter_default" 2>/dev/null || true
          rm -f "$cfg_file_hub" 2>/dev/null || true
        fi
      fi
    fi
  fi
  [[ -z ${enter_default:-} ]] && enter_default="open"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --start)
        # Check if next arg looks like a flag (missing value)
        if [[ -z "$2" || "$2" == -* ]]; then
          wt_msg_warn "--start requires a value (list|new), using 'list'"
          start_mode="list"
          shift
        elif [[ "$2" != "list" && "$2" != "new" ]]; then
          wt_msg_warn "Invalid --start value '$2', using 'list'"
          start_mode="list"
          shift 2
        else
          start_mode="$2"
          shift 2
        fi
        ;;
      --detached)
        include_detached=1; shift;;
      --enter-default)
        # Check if next arg looks like a flag (missing value)
        if [[ -z "$2" || "$2" == -* ]]; then
          wt_msg_warn "--enter-default requires a value (open|menu), using 'open'"
          enter_default="open"
          shift
        elif [[ "$2" != "open" && "$2" != "menu" ]]; then
          wt_msg_warn "Invalid --enter-default value '$2', using 'open'"
          enter_default="open"
          shift 2
        else
          enter_default="$2"
          shift 2
        fi
        ;;
      -v|--version)
        echo "git-worktrees wt v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wt [options] [branch]
       wt <subcommand> [args]

Subcommands:
  new, n       Create/open worktree (same as wtnew)
  remove, rm   Remove worktree (same as wtrm)
  open, o      Open worktree (same as wtopen)
  list, ls     List worktrees (same as wtls)
  prune        Remove stale references
  config       Manage configuration (edit, show, init)
  help         Show detailed help

Hub Options:
  --start list|new        Start in list-first or branch-first mode (default: list)
  --detached              Include detached/headless worktrees in list
  --enter-default open|menu  Default Enter behavior (default: open)
  -v, --version           Show version
  -h, --help              Show this help

Examples:
  wt                      Interactive hub
  wt feature              Quick open/create 'feature' branch
  wt new feature          Create worktree for 'feature'

For detailed help: wt help
USAGE
        return 0;;
      --*) echo "Unknown option: $1"; return 2;;
      *) branch_arg="$1"; shift;;
    esac
  done

  if ! wt_git_is_repo; then
    wt_error_not_git_repo
    return 1
  fi
  
  # Use centralized FZF detection
  if ! wt_has_fzf; then
    FZF_MISSING=1
    wt_error_fzf_missing 2>/dev/null || true
  fi

  # Fast path: wt <branch> auto-resolve
  if [[ -n $branch_arg ]]; then
    local br_short="$branch_arg" existing_dir=""
    # Strip remote prefix if present
    if git remote | grep -Fxq "${br_short%%/*}" && [[ "$br_short" == */* ]]; then
      br_short="${br_short#*/}"
    fi
    # Use common porcelain parser to resolve existing worktree path for branch
    local porcelain rows
    porcelain="$(wt_git_worktree_list_porcelain)"
    rows="$(wt_parse_worktrees_porcelain 0 "$porcelain")"
    existing_dir="$(printf "%s\n" "$rows" | awk -F"\t" -v b="$br_short" '$1==b{print $2; exit}')"
    if [[ -n $existing_dir && -d $existing_dir ]]; then
      wt_open_or_show -v "$existing_dir"
      return 0
    else
      # Fallback to wtnew for creation
      if wt_has_cmd wtnew; then
        wtnew -n "$br_short"; return $?
      else
        echo "‚ÑπÔ∏è  No existing worktree for '$br_short'. Install wtnew to create."; return 1
      fi
    fi
  fi

  # Branch-first start (reuse wtnew)
  if [[ "$start_mode" == "new" ]]; then
    wt_run wtnew; return $?
  fi

  # Build list (branch\tpath). Detached hidden by default.
  local selectable porcelain
  porcelain="$(wt_git_worktree_list_porcelain)"
  selectable="$(wt_parse_worktrees_porcelain ${include_detached} "$porcelain")"

  # ============================================================================
  # First-Run Experience (Phase 2 - v1.1.0)
  # ============================================================================
  # Check if this looks like a first run (only 1 worktree = main repo AND no first-run flag set)
  local worktree_count
  worktree_count=$(printf "%s" "$selectable" | sed '/^$/d' | wc -l | tr -d ' ')
  
  # Only show first-run message once (track via config)
  local first_run_shown
  first_run_shown="$(wt_get_config WT_FIRST_RUN_SHOWN "")"
  
  if [[ "$worktree_count" -eq 1 && "$first_run_shown" != "true" ]]; then
    # Mark as shown so we don't show again
    wt_set_config WT_FIRST_RUN_SHOWN true 2>/dev/null || true
    
    cat <<'FIRSTRUN'

üìÇ No additional worktrees found.

üí° What are worktrees?
   Git worktrees let you work on multiple branches simultaneously.
   Each worktree is a separate directory with its own checked-out branch.

   Instead of: git checkout feature ‚Üí git checkout main ‚Üí git checkout bugfix
   You can have: ~/repo-feature/, ~/repo-main/, ~/repo-bugfix/
   All at once! ‚ú®

üöÄ Get started:
   wt new <branch-name>    # Create your first worktree
   wt new feature -b main  # Create from specific base branch
   
üìñ Learn more:
   wt --tutorial           # Interactive tutorial
   wt help                 # Full documentation

FIRSTRUN
    return 0
  fi
  
  # If there's only 1 worktree but we've shown the first-run message before,
  # just show a brief hint
  if [[ "$worktree_count" -eq 1 ]]; then
    echo "‚ÑπÔ∏è  Only the main worktree exists. Use 'wt new <branch>' to create more."
    return 0
  fi

  # Prepend New branch row
  selectable="‚ûï New branch‚Ä¶"$'\t'$'(create)'$'\n'"$selectable"
  if (( ! include_detached )); then
    selectable="üßµ Show detached‚Ä¶"$'\t'$'(toggle)'$'\n'"$selectable"
  fi

  wt_debug "wt selectable count: $(printf "%s" "$selectable" | sed '/^$/d' | wc -l)"
  wt_debug "selectable START"
  if [[ -n ${WT_DEBUG:-} ]]; then printf "%s\n" "$selectable" >&2; fi
  wt_debug "selectable END"

  if [[ -n $FZF_MISSING ]]; then
    echo "üìù  Worktrees (branch -> dir):"
    printf "%s" "$selectable" | awk -F"\t" '{printf "- %s  \t%s\n", $1, $2}'
    printf "Pick a branch or 'New branch‚Ä¶': "; local sel; read -r sel
    [[ -z $sel ]] && { wt_msg_error "No selection"; return 1; }
    if [[ "$sel" == "‚ûï New branch"* ]]; then
      wt_run wtnew; return $?
    elif [[ "$sel" == "üßµ Show detached"* ]]; then
      wt --detached --start list; return $?
    else
      local path; path="$(printf "%s" "$selectable" | awk -F"\t" -v b="$sel" '$1==b{print $2; exit}')"
      [[ -z $path ]] && { wt_msg_error "Unknown selection"; return 1; }
      wt_open_or_show "$path"
      return 0
    fi
  fi

  local out key line
  local header="Enter=open ‚îÇ ^N=new ‚îÇ ^D=remove ‚îÇ ^A=actions ‚îÇ ^P=prune ‚îÇ ^E=toggle-enter ‚îÇ ^H=help"
  out="$(printf "%s" "$selectable" | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} --prompt='üìÇ  Worktrees: ' --header="$header" --with-nth=1 --delimiter=$'\t' --expect=enter,ctrl-o,ctrl-d,ctrl-p,ctrl-n,ctrl-r,ctrl-a,ctrl-e,ctrl-h --preview 'd=$(printf %s {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; git -C "$d" status -sb --untracked-files=all 2>/dev/null; echo; git -C "$d" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null; fi' --preview-window=right,60%)" || true

  key="$(printf "%s" "$out" | head -n1)"
  line="$(printf "%s" "$out" | sed -n '2p')"
  [[ -z $line ]] && { wt_msg_error "No selection"; return 1; }

  local sel_branch sel_path tab
  tab=$'\t'
  sel_branch="${line%%${tab}*}"; sel_path="${line#*${tab}}"; sel_path="${sel_path%%${tab}*}"
  
  # Echo selection for context
  if [[ "$sel_branch" == "‚ûï New branch‚Ä¶" ]]; then
    echo "‚úì Creating new worktree"
  elif [[ "$sel_branch" == "üßµ Show detached‚Ä¶" ]]; then
    echo "‚úì Toggling detached worktrees"
  else
    echo "‚úì Selected: $sel_branch"
  fi
  
  wt_debug "key=[$key] line=[$line] sel_branch=[$sel_branch] sel_path=[$sel_path]"

  # New branch row
  if [[ "$sel_branch" == "‚ûï New branch"* ]]; then
    wt_run wtnew; return $?
  fi

  # Show detached toggle row
  if [[ "$sel_branch" == "üßµ Show detached"* || "$sel_path" == "(toggle)" ]]; then
    include_detached=1; wt --detached --start list "$@"; return $?
  fi

  # Map keys
  case "${key:-enter}" in
    enter|ctrl-o)
      if [[ "$enter_default" == "menu" ]]; then
        # Open actions menu instead of opening directly (same options as Ctrl-A)
        local outa
        outa="$(printf "%s\n" "Open" "Show path" "Copy path" "Open in terminal" "Print cd command" "Change editor" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="‚öôÔ∏è  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$outa" in
          ("Open") wt_open_or_show "$sel_path";;
          ("Show path") echo "$sel_path";;
          ("Copy path")
            if command -v pbcopy >/dev/null 2>&1; then
              printf "%s" "$sel_path" | pbcopy && echo "üìã Copied: $sel_path"
            else
              echo "$sel_path"
            fi;;
          ("Open in terminal")
            local term_app="${WT_TERMINAL_APP:-iTerm}"
            open -a "$term_app" "$sel_path" >/dev/null 2>&1 || open -a Terminal "$sel_path" >/dev/null 2>&1 || wt_msg_error "Could not open terminal";;
          ("Print cd command")
            echo "$(wt_cd_command "$sel_path")";;
          ("Change editor")
            wt_change_editor_interactive || return 1
            ;;
          ("Remove") wt_run wtrm -d "$sel_path";;
          ("Remove all detached") wt_run wtrm --rm-detached;;
          ("Prune stale") if wt_has_cmd wtrm; then wtrm --prune-only; else git worktree prune -v; fi;;
          ("Set upstream (origin)")
            local b="${sel_branch}"; local remote="origin"
            if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
              git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "‚úÖ Upstream: $remote/$b" || wt_msg_error "Failed to set upstream"
            else
              echo "‚ÑπÔ∏è  Remote $remote/$b not found. Trying push -u‚Ä¶"
              git -C "$sel_path" push -u "$remote" "$b" || wt_msg_error "Push failed"
            fi;;
        esac
        return 0
      fi
      wt_open_or_show "$sel_path"
      ;;
    ctrl-d)
      wt_run wtrm -d "$sel_path"
      ;;
    ctrl-p)
      if wt_has_cmd wtrm; then wtrm --prune-only; else git worktree prune -v || true; fi
      ;;
    ctrl-n)
      if wt_has_cmd wtnew; then
        # Choose creation mode
        local mode
        mode="$(printf "%s\n" "Create (smart reuse)" "Create (force reuse)" "Create (new dir)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="‚ûï New: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$mode" in
          ("Create (force reuse)") wtnew --prefer-reuse;;
          ("Create (new dir)") WTNEW_PREFER_REUSE= wtnew;;
          (*) wtnew;;
        esac
      else
        wt_msg_error "wtnew not available"
      fi
      ;;
    ctrl-r)
      if wt_has_cmd wtnew; then
        wtnew --prefer-reuse
      else
        wt_msg_error "wtnew not available"
      fi
      ;;
    ctrl-a)
      # Simple actions menu
      local outa
      outa="$(printf "%s\n" "Open" "Show path" "Copy path" "Open in terminal" "Print cd command" "Change editor" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
        | FZF_DEFAULT_OPTS= command fzf --prompt="‚öôÔ∏è  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
      case "$outa" in
        ("Open") wt_open_or_show "$sel_path";;
        ("Show path") echo "$sel_path";;
        ("Copy path")
          if command -v pbcopy >/dev/null 2>&1; then
            printf "%s" "$sel_path" | pbcopy && echo "üìã Copied: $sel_path"
          else
            echo "$sel_path"
          fi;;
        ("Open in terminal")
          local term_app="${WT_TERMINAL_APP:-iTerm}"
          open -a "$term_app" "$sel_path" >/dev/null 2>&1 || open -a Terminal "$sel_path" >/dev/null 2>&1 || wt_msg_error "Could not open terminal";;
        ("Print cd command")
          echo "$(wt_cd_command "$sel_path")";;
        ("Change editor")
          wt_change_editor_interactive || return 1
          ;;
        ("Remove") wt_run wtrm -d "$sel_path";;
        ("Remove all detached") wt_run wtrm --rm-detached;;
        ("Prune stale") if wt_has_cmd wtrm; then wtrm --prune-only; else git worktree prune -v; fi;;
        ("Set upstream (origin)")
          local b="${sel_branch}"; local remote="origin"
          if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
            git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "‚úÖ Upstream: $remote/$b" || wt_msg_error "Failed to set upstream"
          else
            echo "‚ÑπÔ∏è  Remote $remote/$b not found. Trying push -u‚Ä¶"
            git -C "$sel_path" push -u "$remote" "$b" || wt_msg_error "Push failed"
          fi;;
      esac
      ;;
    ctrl-e)
      # Toggle Enter default between open and menu, then re-run hub with same view
      if [[ "$enter_default" == "open" ]]; then
        wt_set_config WT_ENTER_BEHAVIOR menu 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=menu wt ${include_detached:+--detached} --start list
      else
        wt_set_config WT_ENTER_BEHAVIOR open 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=open wt ${include_detached:+--detached} --start list
      fi
      return $?
      ;;
    ctrl-h)
      cat <<HELP
wt hub
  Enter: ${enter_default}   (Ctrl-E toggles)
  Keys:  Ctrl-N new   Ctrl-R new (reuse)   Ctrl-D remove   Ctrl-P prune   Ctrl-A actions   Ctrl-O open   Ctrl-H help
  Rows:  "‚ûï New branch‚Ä¶" starts branch-first flow; "üßµ Show detached‚Ä¶" toggles headless entries
HELP
      ;;
    *)
      # Default fallback: open
      wt_open_or_show "$sel_path"
      ;;
  esac
}


