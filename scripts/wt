# wt: hub for listing and acting on Git worktrees
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WT__SCRIPT_FILE WT__SCRIPT_DIR WT__COMMON_LIB
WT__SCRIPT_FILE=${(%):-%N}
if [[ -n $WT__SCRIPT_FILE && -f $WT__SCRIPT_FILE ]]; then
  WT__SCRIPT_DIR="${WT__SCRIPT_FILE:A:h}"
else
  WT__SCRIPT_DIR="${0:A:h}"
fi
WT__COMMON_LIB="${WT__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WT__COMMON_LIB" ]] && source "$WT__COMMON_LIB" || true
wt() {
  emulate -L zsh
  setopt local_options pipefail
  unsetopt xtrace verbose
  set +xv 2>/dev/null || true

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true

  # ============================================================================
  # Subcommand Dispatch (Phase 2 - v1.1.0)
  # ============================================================================
  
  # Special case: --tutorial flag (show interactive tutorial)
  if [[ "$1" == "--tutorial" ]]; then
    cat <<'TUTORIAL'

╔═══════════════════════════════════════════════════════════════╗
║            Welcome to git-worktrees! (1/4)                    ║
╚═══════════════════════════════════════════════════════════════╝

What are worktrees?
───────────────────
Git worktrees let you check out multiple branches at once.

Instead of constantly switching branches:
  $ git checkout feature
  $ git checkout main
  $ git checkout bugfix

You have separate directories:
  ~/code/repo/          → main branch
  ~/code/repo-feature/  → feature branch
  ~/code/repo-bugfix/   → bugfix branch

All active at the same time! 🎉

Benefits:
  ✓ No need to stash/unstash
  ✓ Work on multiple features simultaneously
  ✓ Keep builds running while you code
  ✓ Compare branches side-by-side

TUTORIAL
    printf "\nPress Enter to continue, or 'q' to quit... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

╔═══════════════════════════════════════════════════════════════╗
║               Creating Worktrees (2/4)                        ║
╚═══════════════════════════════════════════════════════════════╝

To create your first worktree:

  $ wt new feature-branch

This will:
  1. Create branch 'feature-branch' (if it doesn't exist)
  2. Create directory '../repo-feature-branch/'
  3. Check out the branch there
  4. Open in your editor (auto-detected)

Advanced options:
  $ wt new feature -b main       # Create from 'main' branch
  $ wt new feature --no-open     # Don't open editor
  $ wt new feature --push        # Also push to remote

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

╔═══════════════════════════════════════════════════════════════╗
║              Managing Worktrees (3/4)                         ║
╚═══════════════════════════════════════════════════════════════╝

Key commands:
────────────
  wt                # Interactive hub (fuzzy find)
  wt new <name>     # Create worktree
  wt open <name>    # Open existing worktree
  wt remove         # Remove worktree (safe, with checks)
  wt list           # Show all worktrees with status

Keyboard shortcuts in 'wt' hub:
────────────────────────────────
  Enter   → Open selected worktree
  Ctrl-N  → Create new worktree
  Ctrl-D  → Remove worktree
  Ctrl-A  → Actions menu
  Ctrl-P  → Prune stale worktrees
  Ctrl-H  → Show help

TUTORIAL
    printf "\nPress Enter to continue... "
    read -r response
    [[ "$response" == "q" ]] && return 0

    cat <<'TUTORIAL'

╔═══════════════════════════════════════════════════════════════╗
║                 You're Ready! (4/4)                           ║
╚═══════════════════════════════════════════════════════════════╝

Quick start workflow:
────────────────────
  1. Run 'wt new my-feature' to create your first worktree
  2. Work in the new worktree directory
  3. Run 'wt' anytime to switch between worktrees
  4. Use 'wt remove' when you're done with a branch

Tips:
─────
  • Each worktree is independent - changes don't affect others
  • You can have multiple IDE windows open, one per worktree
  • Worktrees share the same .git database (efficient!)
  • Great for reviewing PRs while keeping your work intact

More help:
──────────
  wt help           # Full documentation
  wt new --help     # Command-specific help
  wt remove --help  # More options

Happy coding! ✨

TUTORIAL
    return 0
  fi
  
  # Check if first arg is a subcommand (git-style: wt new, wt remove, etc.)
  if [[ $# -gt 0 ]]; then
    case "$1" in
      new|n)
        shift
        if command -v wtnew >/dev/null 2>&1; then
          wtnew "$@"
          return $?
        else
          echo "❌ wtnew command not found"; return 1
        fi
        ;;
      remove|rm)
        shift
        if command -v wtrm >/dev/null 2>&1; then
          wtrm "$@"
          return $?
        else
          echo "❌ wtrm command not found"; return 1
        fi
        ;;
      open|o)
        shift
        if command -v wtopen >/dev/null 2>&1; then
          wtopen "$@"
          return $?
        else
          echo "❌ wtopen command not found"; return 1
        fi
        ;;
      list|ls)
        shift
        if command -v wtls >/dev/null 2>&1; then
          wtls "$@"
          return $?
        else
          echo "❌ wtls command not found"; return 1
        fi
        ;;
      prune)
        shift
        if command -v wtrm >/dev/null 2>&1; then
          wtrm --prune-only "$@"
          return $?
        else
          git worktree prune -v
          return $?
        fi
        ;;
      config)
        shift
        local action="${1:-show}"
        case "$action" in
          init)
            if typeset -f wt_init_config >/dev/null 2>&1; then
              wt_init_config
            else
              echo "❌ Config initialization not available"
              return 1
            fi
            ;;
          edit)
            local config_file="${HOME}/.config/git-worktrees/config"
            if [[ ! -f "$config_file" ]]; then
              echo "⚠️  Config file doesn't exist. Creating it..."
              if typeset -f wt_init_config >/dev/null 2>&1; then
                wt_init_config
              fi
            fi
            local editor="${EDITOR:-${VISUAL:-vim}}"
            "$editor" "$config_file"
            ;;
          show|path)
            local config_file="${HOME}/.config/git-worktrees/config"
            if [[ -f "$config_file" ]]; then
              echo "Config file: $config_file"
              echo ""
              cat "$config_file"
            else
              echo "No config file found."
              echo "Run 'wt config init' to create one."
            fi
            ;;
          *)
            cat <<'CONFIGHELP'
Usage: wt config <action>

Actions:
  show     Show current config (default)
  edit     Edit config in $EDITOR
  init     Initialize config with defaults
  path     Show config file path

Config file location: ~/.config/git-worktrees/config

Examples:
  wt config          # Show current config
  wt config edit     # Edit in your editor
  wt config init     # Create with defaults
CONFIGHELP
            ;;
        esac
        return 0
        ;;
      help|h)
        # Show comprehensive help with subcommands
        cat <<'HELP'
git-worktrees - Manage Git worktrees with ease

Usage:
  wt [options]                 Interactive worktree hub (fuzzy find)
  wt <branch>                  Quick open/create worktree for branch
  wt <subcommand> [args]       Run subcommand

Subcommands:
  new, n       Create/open worktree for a branch
  open, o      Open existing worktree
  remove, rm   Remove worktree safely
  list, ls     List all worktrees with status
  prune        Remove stale worktree references
  config       Manage configuration
  help, h      Show this help

Hub Options:
  --start list|new             Start in list or branch-first mode
  --detached                   Include detached worktrees
  --enter-default open|menu    Default Enter key behavior
  -v, --version                Show version
  -h, --help                   Show help

Examples:
  wt                          # Interactive hub
  wt feature                  # Quick open 'feature' branch
  wt new feature              # Create worktree for 'feature'
  wt new feature -b main      # Create from 'main' branch
  wt remove                   # Interactive removal
  wt list                     # List all worktrees

For command-specific help:
  wt new --help
  wt remove --help
  wt open --help
  wt list --help

Documentation: https://github.com/EtienneBBeaulac/git-worktrees
HELP
        return 0
        ;;
      # Not a subcommand - continue with existing logic
      -*|--*)
        # It's a flag, process normally below
        ;;
      *)
        # Could be a branch name, process normally below
        ;;
    esac
  fi

  # ============================================================================
  # Original Hub Logic (Interactive Mode / Branch Fast Path)
  # ============================================================================
  
  local start_mode="list" include_detached=0 enter_default="${WTHUB_ENTER_DEFAULT:-}"
  local branch_arg="" FZF_MISSING=

  # Centralized config: prefer runtime env/flags; fall back to config
  typeset -gA WT_CONFIG
  typeset cfg_file_hub
  wt_load_config 2>/dev/null || true
  enter_default="${enter_default:-${WTHUB_ENTER_DEFAULT:-}}"
  if [[ -z ${enter_default:-} ]]; then
    # Back-compat: also read historical hub file if present
    cfg_file_hub="$HOME/.config/git-worktrees/hub"
    if [[ -f "$cfg_file_hub" ]]; then
      enter_default="$(awk -F'=' '/^ENTER_DEFAULT=/{print $2}' "$cfg_file_hub" | tail -n1)"
    else
      enter_default="$(wt_get_config WT_ENTER_BEHAVIOR open)"
    fi
  fi
  [[ -z ${enter_default:-} ]] && enter_default="open"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --start)
        start_mode="$2"; shift 2;;
      --detached)
        include_detached=1; shift;;
      --enter-default)
        enter_default="$2"; shift 2;;
      -v|--version)
        echo "git-worktrees wt v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wt [options] [branch]
       wt <subcommand> [args]

Subcommands:
  new, n       Create/open worktree (same as wtnew)
  remove, rm   Remove worktree (same as wtrm)
  open, o      Open worktree (same as wtopen)
  list, ls     List worktrees (same as wtls)
  prune        Remove stale references
  config       Manage configuration (edit, show, init)
  help         Show detailed help

Hub Options:
  --start list|new        Start in list-first or branch-first mode (default: list)
  --detached              Include detached/headless worktrees in list
  --enter-default open|menu  Default Enter behavior (default: open)
  -v, --version           Show version
  -h, --help              Show this help

Examples:
  wt                      Interactive hub
  wt feature              Quick open/create 'feature' branch
  wt new feature          Create worktree for 'feature'

For detailed help: wt help
USAGE
        return 0;;
      --*) echo "Unknown option: $1"; return 2;;
      *) branch_arg="$1"; shift;;
    esac
  done

  if ! git rev-parse --git-dir &>/dev/null; then
    if typeset -f wt_error_not_git_repo >/dev/null 2>&1; then
      wt_error_not_git_repo
    else
      echo "❌ Not a git repository" >&2
    fi
    return 1
  fi
  
  if ! command -v fzf >/dev/null; then
    FZF_MISSING=1
    if typeset -f wt_error_fzf_missing >/dev/null 2>&1; then
      wt_error_fzf_missing
    fi
  fi

  # Fast path: wt <branch> auto-resolve
  if [[ -n $branch_arg ]]; then
    local br_short="$branch_arg" existing_dir=""
    # Strip remote prefix if present
    if git remote | grep -Fxq "${br_short%%/*}" && [[ "$br_short" == */* ]]; then
      br_short="${br_short#*/}"
    fi
    # Use common porcelain parser to resolve existing worktree path for branch
    local porcelain rows
    porcelain="$(git worktree list --porcelain 2>/dev/null)"
    rows="$(wt_parse_worktrees_porcelain 0 "$porcelain")"
    existing_dir="$(printf "%s\n" "$rows" | awk -F"\t" -v b="$br_short" '$1==b{print $2; exit}')"
    if [[ -n $existing_dir && -d $existing_dir ]]; then
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        echo "🚀  Opening in ${detected_app}…"
        if typeset -f wt_open_in_android_studio >/dev/null 2>&1; then
          wt_open_in_android_studio "$existing_dir" "$detected_app"
        else
          open -a "$detected_app" "$existing_dir" >/dev/null 2>&1 || true
        fi
      else
        echo "ℹ️  Worktree is at: $existing_dir"
      fi
      return 0
    else
      # Fallback to wtnew for creation
      if command -v wtnew >/dev/null 2>&1; then
        wtnew -n "$br_short"
        return $?
      else
        echo "ℹ️  No existing worktree for '$br_short'. Install wtnew to create."; return 1
      fi
    fi
  fi

  # Branch-first start (reuse wtnew)
  if [[ "$start_mode" == "new" ]]; then
    if command -v wtnew >/dev/null 2>&1; then
      wtnew
      return $?
    else
      echo "❌ wtnew not available"; return 1
    fi
  fi

  # Build list (branch\tpath). Detached hidden by default.
  local selectable porcelain
  porcelain="$(git worktree list --porcelain 2>/dev/null)"
  selectable="$(wt_parse_worktrees_porcelain ${include_detached} "$porcelain")"

  # ============================================================================
  # First-Run Experience (Phase 2 - v1.1.0)
  # ============================================================================
  # Check if this looks like a first run (only 1 worktree = main repo)
  local worktree_count
  worktree_count=$(printf "%s" "$selectable" | sed '/^$/d' | wc -l | tr -d ' ')
  
  if [[ "$worktree_count" -eq 1 ]]; then
    cat <<'FIRSTRUN'

📂 No additional worktrees found.

💡 What are worktrees?
   Git worktrees let you work on multiple branches simultaneously.
   Each worktree is a separate directory with its own checked-out branch.

   Instead of: git checkout feature → git checkout main → git checkout bugfix
   You can have: ~/repo-feature/, ~/repo-main/, ~/repo-bugfix/
   All at once! ✨

🚀 Get started:
   wt new <branch-name>    # Create your first worktree
   wt new feature -b main  # Create from specific base branch
   
📖 Learn more:
   wt --tutorial           # Interactive tutorial
   wt help                 # Full documentation

FIRSTRUN
    return 0
  fi

  # Prepend New branch row
  selectable="➕ New branch…"$'\t'$'(create)'$'\n'"$selectable"
  if (( ! include_detached )); then
    selectable="🧵 Show detached…"$'\t'$'(toggle)'$'\n'"$selectable"
  fi

  wt_debug "wt selectable count: $(printf "%s" "$selectable" | sed '/^$/d' | wc -l)"
  wt_debug "selectable START"
  if [[ -n ${WT_DEBUG:-} ]]; then printf "%s\n" "$selectable" >&2; fi
  wt_debug "selectable END"

  if [[ -n $FZF_MISSING ]]; then
    echo "📝  Worktrees (branch -> dir):"
    printf "%s" "$selectable" | awk -F"\t" '{printf "- %s  \t%s\n", $1, $2}'
    printf "Pick a branch or 'New branch…': "; local sel; read -r sel
    [[ -z $sel ]] && { echo "❌ No selection"; return 1; }
    if [[ "$sel" == "➕ New branch"* ]]; then
      if command -v wtnew >/dev/null 2>&1; then
        wtnew
      else
        echo "❌ wtnew not available"
      fi
      return $?
    elif [[ "$sel" == "🧵 Show detached"* ]]; then
      wt --detached --start list; return $?
    else
      local path; path="$(printf "%s" "$selectable" | awk -F"\t" -v b="$sel" '$1==b{print $2; exit}')"
      [[ -z $path ]] && { echo "❌ Unknown selection"; return 1; }
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$path" "$detected_app" \
          || open -a "$detected_app" "$path" >/dev/null 2>&1 || true
      else
        echo "ℹ️  Worktree is at: $path"
      fi
      return 0
    fi
  fi

  local out key line
  local header="Enter=open │ ^N=new │ ^D=remove │ ^A=actions │ ^P=prune │ ^E=toggle-enter │ ^H=help"
  out="$(printf "%s" "$selectable" | FZF_DEFAULT_OPTS= command fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} --prompt='📂  Worktrees: ' --header="$header" --with-nth=1 --delimiter=$'\t' --expect=enter,ctrl-o,ctrl-d,ctrl-p,ctrl-n,ctrl-r,ctrl-a,ctrl-e,ctrl-h --preview 'd=$(printf %s {} | cut -f2-); if [ -d "$d" ]; then echo "Path: $d"; echo; git -C "$d" status -sb --untracked-files=all 2>/dev/null; echo; git -C "$d" log --oneline -n 15 --decorate --graph --color=always 2>/dev/null; fi' --preview-window=right,60%)" || true

  key="$(printf "%s" "$out" | head -n1)"
  line="$(printf "%s" "$out" | sed -n '2p')"
  [[ -z $line ]] && { echo "❌ No selection"; return 1; }

  local sel_branch sel_path tab
  tab=$'\t'
  sel_branch="${line%%${tab}*}"; sel_path="${line#*${tab}}"; sel_path="${sel_path%%${tab}*}"
  
  # Echo selection for context
  if [[ "$sel_branch" == "➕ New branch…" ]]; then
    echo "✓ Creating new worktree"
  elif [[ "$sel_branch" == "🧵 Show detached…" ]]; then
    echo "✓ Toggling detached worktrees"
  else
    echo "✓ Selected: $sel_branch"
  fi
  
  wt_debug "key=[$key] line=[$line] sel_branch=[$sel_branch] sel_path=[$sel_path]"

  # New branch row
  if [[ "$sel_branch" == "➕ New branch"* ]]; then
    command -v wtnew >/dev/null 2>&1 && wtnew || echo "❌ wtnew not available"
    return $?
  fi

  # Show detached toggle row
  if [[ "$sel_branch" == "🧵 Show detached"* || "$sel_path" == "(toggle)" ]]; then
    include_detached=1; wt --detached --start list "$@"; return $?
  fi

  # Map keys
  case "${key:-enter}" in
    enter|ctrl-o)
      if [[ "$enter_default" == "menu" ]]; then
        # Open actions menu instead of opening directly
        local outa
        outa="$(printf "%s\n" "Open" "Show path" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="⚙️  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$outa" in
          ("Open")
            local detected_app
            detected_app="$(wt_get_editor 2>/dev/null)" || true
            if [[ -n "$detected_app" ]]; then
              typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
                && wt_open_in_android_studio "$sel_path" "$detected_app" \
                || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
            else
              echo "ℹ️  Worktree is at: $sel_path"
            fi;;
          ("Show path") echo "$sel_path";;
          ("Remove") command -v wtrm >/dev/null 2>&1 && wtrm -d "$sel_path" || echo "❌ wtrm not available";;
          ("Remove all detached") command -v wtrm >/dev/null 2>&1 && wtrm --rm-detached || echo "❌ wtrm not available";;
          ("Prune stale") command -v wtrm >/dev/null 2>&1 && wtrm --prune-only || git worktree prune -v;;
          ("Set upstream (origin)")
            local b="${sel_branch}"; local remote="origin"
            if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
              git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "✅ Upstream: $remote/$b" || echo "❌ Failed to set upstream"
            else
              echo "ℹ️  Remote $remote/$b not found. Trying push -u…"
              git -C "$sel_path" push -u "$remote" "$b" || echo "❌ Push failed"
            fi;;
        esac
        return 0
      fi
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$sel_path" "$detected_app" \
          || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
      else
        echo "ℹ️  Worktree is at: $sel_path"
      fi
      ;;
    ctrl-d)
      if command -v wtrm >/dev/null 2>&1; then
        wtrm -d "$sel_path"
      else
        echo "❌ wtrm not available"
      fi
      ;;
    ctrl-p)
      if command -v wtrm >/dev/null 2>&1; then
        wtrm --prune-only
      else
        git worktree prune -v || true
      fi
      ;;
    ctrl-n)
      if command -v wtnew >/dev/null 2>&1; then
        # Choose creation mode
        local mode
        mode="$(printf "%s\n" "Create (smart reuse)" "Create (force reuse)" "Create (new dir)" \
          | FZF_DEFAULT_OPTS= command fzf --prompt="➕ New: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$mode" in
          ("Create (force reuse)") wtnew --prefer-reuse;;
          ("Create (new dir)") WTNEW_PREFER_REUSE= wtnew;;
          (*) wtnew;;
        esac
      else
        echo "❌ wtnew not available"
      fi
      ;;
    ctrl-r)
      if command -v wtnew >/dev/null 2>&1; then
        wtnew --prefer-reuse
      else
        echo "❌ wtnew not available"
      fi
      ;;
    ctrl-a)
      # Simple actions menu
      local act outa
      outa="$(printf "%s\n" "Open" "Show path" "Copy path" "Open in terminal" "Print cd command" "Remove" "Remove all detached" "Prune stale" "Set upstream (origin)" \
        | FZF_DEFAULT_OPTS= command fzf --prompt="⚙️  Action: " --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-})" || true
        case "$outa" in
        ("Open")
          local detected_app
          detected_app="$(wt_get_editor 2>/dev/null)" || true
          if [[ -n "$detected_app" ]]; then
            typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
              && wt_open_in_android_studio "$sel_path" "$detected_app" \
              || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
          else
            echo "ℹ️  Worktree is at: $sel_path"
          fi;;
        ("Show path") echo "$sel_path";;
        ("Copy path")
          if command -v pbcopy >/dev/null 2>&1; then
            printf "%s" "$sel_path" | pbcopy && echo "📋 Copied: $sel_path"
          else
            echo "$sel_path"
          fi;;
        ("Open in terminal")
          local term_app="${WT_TERMINAL_APP:-iTerm}"
          open -a "$term_app" "$sel_path" >/dev/null 2>&1 || open -a Terminal "$sel_path" >/dev/null 2>&1 || echo "❌ Could not open terminal";;
        ("Print cd command")
          echo "cd '$sel_path'";;
        ("Remove") command -v wtrm >/dev/null 2>&1 && wtrm -d "$sel_path" || echo "❌ wtrm not available";;
        ("Remove all detached") command -v wtrm >/dev/null 2>&1 && wtrm --rm-detached || echo "❌ wtrm not available";;
        ("Prune stale") command -v wtrm >/dev/null 2>&1 && wtrm --prune-only || git worktree prune -v;;
        ("Set upstream (origin)")
          local b="${sel_branch}"; local remote="origin"
          if git -C "$sel_path" show-ref --verify --quiet "refs/remotes/$remote/$b"; then
            git -C "$sel_path" branch --set-upstream-to="$remote/$b" >/dev/null 2>&1 && echo "✅ Upstream: $remote/$b" || echo "❌ Failed to set upstream"
          else
            echo "ℹ️  Remote $remote/$b not found. Trying push -u…"
            git -C "$sel_path" push -u "$remote" "$b" || echo "❌ Push failed"
          fi;;
      esac
      ;;
    ctrl-e)
      # Toggle Enter default between open and menu, then re-run hub with same view
      if [[ "$enter_default" == "open" ]]; then
        local cfg_dir; cfg_dir="$HOME/.config/git-worktrees"; local cfg_file; cfg_file="$cfg_dir/hub"
        mkdir -p "$cfg_dir" 2>/dev/null || true
        { printf "%s\n" "ENTER_DEFAULT=menu"; } > "$cfg_file" 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=menu wt ${include_detached:+--detached} --start list
      else
        local cfg_dir; cfg_dir="$HOME/.config/git-worktrees"; local cfg_file; cfg_file="$cfg_dir/hub"
        mkdir -p "$cfg_dir" 2>/dev/null || true
        { printf "%s\n" "ENTER_DEFAULT=open"; } > "$cfg_file" 2>/dev/null || true
        WTHUB_ENTER_DEFAULT=open wt ${include_detached:+--detached} --start list
      fi
      return $?
      ;;
    ctrl-h)
      cat <<HELP
wt hub
  Enter: ${enter_default}   (Ctrl-E toggles)
  Keys:  Ctrl-N new   Ctrl-R new (reuse)   Ctrl-D remove   Ctrl-P prune   Ctrl-A actions   Ctrl-O open   Ctrl-H help
  Rows:  "➕ New branch…" starts branch-first flow; "🧵 Show detached…" toggles headless entries
HELP
      ;;
    *)
      # Default fallback: open
      local detected_app
      detected_app="$(wt_get_editor 2>/dev/null)" || true
      if [[ -n "$detected_app" ]]; then
        typeset -f wt_open_in_android_studio >/dev/null 2>&1 \
          && wt_open_in_android_studio "$sel_path" "$detected_app" \
          || open -a "$detected_app" "$sel_path" >/dev/null 2>&1 || true
      else
        echo "ℹ️  Worktree is at: $sel_path"
      fi
      ;;
  esac
}


