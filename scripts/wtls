# wtls: list Git worktrees with status, optional fzf picker
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WTLS__SCRIPT_FILE WTLS__SCRIPT_DIR WTLS__COMMON_LIB
WTLS__SCRIPT_FILE=${(%):-%N}
if [[ -n $WTLS__SCRIPT_FILE && -f $WTLS__SCRIPT_FILE ]]; then
  WTLS__SCRIPT_DIR="${WTLS__SCRIPT_FILE:A:h}"
else
  WTLS__SCRIPT_DIR="${0:A:h}"
fi
WTLS__COMMON_LIB="${WTLS__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WTLS__COMMON_LIB" ]] && source "$WTLS__COMMON_LIB" || true
wtls() {
  emulate -L zsh
  setopt local_options pipefail no_xtrace

  # helpers are sourced at load time
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true

  local use_fzf=0 do_open=0 open_app="" prune_stale=0
  local fast_mode=0
  # Env toggle for fast mode (handles true/false, yes/no, on/off, 1/0)
  wt_parse_bool "${WT_FAST:-}" && fast_mode=1
  local FZF_MISSING=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --fzf)         use_fzf=1; shift;;
      --open)        do_open=1; shift;;
      --no-open)     do_open=0; shift;;
      --app)         open_app="$2"; shift 2;;
      --prune-stale) prune_stale=1; shift;;
      --fast)        fast_mode=1; shift;;
      -v|--version)
        echo "git-worktrees wtls v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wtls [--fzf] [--open] [--app NAME] [--prune-stale] [--fast]
  --fzf          Interactive picker with preview
  --open         When picking with --fzf, open the selected worktree in your editor
  --no-open      Do not open, even if --open is set (print path)
  --app NAME     App to open (default: auto-detected)
  --prune-stale  Prune stale/prunable worktrees and exit
  --fast         Skip ahead/behind computation for speed
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  if ! wt_git_is_repo; then
    wt_error_not_git_repo
    return 1
  fi

  # Warn if --open is used without --fzf (it has no effect)
  if (( do_open && !use_fzf )); then
    wt_msg_warn "--open requires --fzf for interactive selection"
    echo "   Usage: wtls --fzf --open"
    echo ""
  fi

  if (( prune_stale )); then
    echo "ðŸ§¹  Pruning stale worktreesâ€¦"
    git worktree prune -v || true
    return 0
  fi

  # Use centralized FZF detection
  if ! wt_has_fzf; then
    FZF_MISSING=1
    if (( use_fzf )); then
      wt_msg_warn "FZF not installed, falling back to table output"
      echo "   Install: brew install fzf (macOS) or apt install fzf (Linux)"
      echo ""
    fi
  fi

  # Parse worktrees via shared helper: path|branch|head
  local porcelain wt_table
  porcelain="$(wt_git_worktree_list_porcelain)"
  wt_table="$(wt_parse_worktrees_table "$porcelain")"

  [[ -z "$wt_table" ]] && { echo "â„¹ï¸  No worktrees found."; return 0; }

  # Build table with short branch and status
  local lines=""
  local IFS=$'\n'
  local row
  for row in ${(f)wt_table}; do
    local dir="${row%%|*}"
    local rest="${row#*|}"
    local br_full="${rest%%|*}"
    local head="${rest##*|}"
    local shortbr
    shortbr="$(wt_short_ref "$br_full")"
    [[ -z "$shortbr" ]] && shortbr="(detached)@${head:0:7}"

    # Determine status (clean/dirty) and optionally ahead/behind
    local status_text="" dirty ahead behind upstream
    dirty="$(git -C "$dir" status --porcelain --untracked-files=all 2>/dev/null)"
    if [[ -n "$dirty" ]]; then
      status_text+="dirty"
    else
      status_text+="clean"
    fi
    if (( ! fast_mode )); then
      upstream="$(git -C "$dir" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
      local compare_ref=""
      if [[ -n "$upstream" ]]; then
        compare_ref="$upstream"
      else
        compare_ref="$(wt_find_default_branch "$dir")" || true
      fi
      # Use centralized default branch detection
      if [[ -n "$compare_ref" ]]; then
        local lr; lr="$(git -C "$dir" rev-list --left-right --count "${compare_ref}...HEAD" 2>/dev/null || echo "0 0")"
        behind="$(echo "$lr" | awk '{print $1}')"
        ahead="$(echo "$lr" | awk '{print $2}')"
        if (( ahead > 0 )); then status_text+=" â†‘${ahead}"; fi
        if (( behind > 0 )); then status_text+=" â†“${behind}"; fi
      fi
    fi

    lines+="$shortbr"$'\t'"$dir"$'\t'"$status_text"$'\n'
  done

  if (( use_fzf )) && [[ -z $FZF_MISSING ]]; then
    local out
    out="$(printf "%s" "$lines" \
      | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
            --prompt="ðŸ“‹ Worktrees: " \
            --with-nth=1,2 --delimiter=$'\t' \
            --preview 'd=$(printf "%s" {} | cut -f2); if [ -d "$d" ]; then cd "$d" && git status -sb --untracked-files=all; echo; git log --oneline -n 20 --decorate --graph --color=always; fi' \
            --preview-window=right,60%)" || { wt_msg_error "No selection"; return 1; }
    local sel_branch sel_dir line
    line="$(printf "%s\n" "$out" | tail -n 1)"
    sel_branch="$(printf "%s\n" "$line" | awk -F"\t" '{print $1}')"
    sel_dir="$(printf "%s\n" "$line" | awk -F"\t" '{print $2}')"
    if (( do_open )); then
      # Detect editor if not specified
      if [[ -z "$open_app" ]]; then
        open_app="$(wt_get_editor 2>/dev/null)" || true
      fi
      
      if [[ -z "$open_app" ]]; then
        echo "â„¹ï¸  Worktree is at: $sel_dir"
      else
        echo "ðŸš€  Opening in ${open_app}â€¦"
      fi
      
      # Debug logging for tests
      [[ -n ${TEST_TMP:-} ]] && {
        {
          echo "sel_dir=$sel_dir"; echo "open_app=$open_app";
          echo "which open: $(command -v open || true)";
          echo "which xdg-open: $(command -v xdg-open || true)";
        } >> "${TEST_TMP}/wtls_dbg.txt" 2>/dev/null || true
      }
      # Test hook: record selection path for verification
      [[ -n ${TEST_TMP:-} ]] && { printf "%s\n" "$sel_dir" >> "${TEST_TMP}/open_calls.txt" 2>/dev/null || true; }
      
      # Use centralized editor opening logic
      wt_open_in_editor "$sel_dir" "$open_app"
      echo "ðŸ“‚  If no window appears, open it manually via File â†’ Openâ€¦ â†’ $sel_dir"
    else
      echo "$sel_dir"
    fi
  else
    # Print tabular list
    printf "%s\n" "$lines" | awk -F"\t" '{printf "%-40s  %-60s  %s\n", $1, $2, $3}'
  fi
}


