# wtls: list Git worktrees with status, optional fzf picker
# macOS + zsh/bash friendly. Requires: git, (optional) fzf

# Resolve script directory and source common helpers at load time (no subshell)
emulate -L zsh
setopt pipefail
typeset -g WTLS__SCRIPT_FILE WTLS__SCRIPT_DIR WTLS__COMMON_LIB
WTLS__SCRIPT_FILE=${(%):-%N}
if [[ -n $WTLS__SCRIPT_FILE && -f $WTLS__SCRIPT_FILE ]]; then
  WTLS__SCRIPT_DIR="${WTLS__SCRIPT_FILE:A:h}"
else
  WTLS__SCRIPT_DIR="${0:A:h}"
fi
WTLS__COMMON_LIB="${WTLS__SCRIPT_DIR}/lib/wt-common.zsh"
[[ -f "$WTLS__COMMON_LIB" ]] && source "$WTLS__COMMON_LIB" || true
wtls() {
  emulate -L zsh
  setopt local_options pipefail no_xtrace

  # Source common helpers if available
  local __WT_LIB="${0:A:h}/lib/wt-common.zsh"
  [[ -f "$__WT_LIB" ]] && source "$__WT_LIB"
  
  # Load editor configuration
  wt_load_editor_config 2>/dev/null || true

  local use_fzf=0 do_open=0 open_app="" prune_stale=0
  local fast_mode=0
  # Env toggle for fast mode
  if [[ -n ${WT_FAST:-} && ${WT_FAST} != 0 && ${WT_FAST:l} != "false" ]]; then
    fast_mode=1
  fi
  local FZF_MISSING=

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --fzf)         use_fzf=1; shift;;
      --open)        do_open=1; shift;;
      --no-open)     do_open=0; shift;;
      --app)         open_app="$2"; shift 2;;
      --prune-stale) prune_stale=1; shift;;
      --fast)        fast_mode=1; shift;;
      -v|--version)
        echo "git-worktrees wtls v${WT_VERSION:-unknown}"
        return 0;;
      -h|--help)
        cat <<'USAGE'
Usage: wtls [--fzf] [--open] [--app NAME] [--prune-stale] [--fast]
  --fzf          Interactive picker with preview
  --open         When picking with --fzf, open the selected worktree in your editor
  --no-open      Do not open, even if --open is set (print path)
  --app NAME     App to open (default: auto-detected)
  --prune-stale  Prune stale/prunable worktrees and exit
  --fast         Skip ahead/behind computation for speed
USAGE
        return 0;;
      *) echo "Unknown option: $1"; return 2;;
    esac
  done

  if ! git rev-parse --git-dir &>/dev/null; then
    if typeset -f wt_error_not_git_repo >/dev/null 2>&1; then
      wt_error_not_git_repo
    else
      echo "❌ Not a git repository" >&2
    fi
    return 1
  fi

  if (( prune_stale )); then
    echo "🧹  Pruning stale worktrees…"
    git worktree prune -v || true
    return 0
  fi

  command -v fzf >/dev/null || FZF_MISSING=1

  # Parse worktrees via shared helper: path|branch|head
  local porcelain wt_table
  porcelain="$(git worktree list --porcelain 2>/dev/null)"
  wt_table="$(wt_parse_worktrees_table "$porcelain")"

  [[ -z "$wt_table" ]] && { echo "ℹ️  No worktrees found."; return 0; }

  # Build table with short branch and status
  local lines=""
  local IFS=$'\n'
  local row
  for row in ${(f)wt_table}; do
    local dir="${row%%|*}"
    local rest="${row#*|}"
    local br_full="${rest%%|*}"
    local head="${rest##*|}"
    local shortbr
    if typeset -f wt_short_ref >/dev/null 2>&1; then
      shortbr="$(wt_short_ref "$br_full")"
    else
      shortbr="$br_full"
    fi
    [[ -z "$shortbr" ]] && shortbr="(detached)@${head:0:7}"

    # Determine status (clean/dirty) and optionally ahead/behind
    local status_text="" dirty ahead behind upstream
    dirty="$(git -C "$dir" status --porcelain --untracked-files=all 2>/dev/null)"
    if [[ -n "$dirty" ]]; then
      status_text+="dirty"
    else
      status_text+="clean"
    fi
    if (( ! fast_mode )); then
      upstream="$(git -C "$dir" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
      local compare_ref=""
      if [[ -n "$upstream" ]]; then
        compare_ref="$upstream"
      else
        # Fallbacks when no upstream: origin/main → origin/master → main → master
        local ref
        for ref in origin/main origin/master main master; do
          if git -C "$dir" rev-parse --verify -q "$ref" >/dev/null; then
            compare_ref="$ref"; break
          fi
        done
      fi
      if [[ -n "$compare_ref" ]]; then
        local lr; lr="$(git -C "$dir" rev-list --left-right --count "${compare_ref}...HEAD" 2>/dev/null || echo "0 0")"
        behind="$(echo "$lr" | awk '{print $1}')"
        ahead="$(echo "$lr" | awk '{print $2}')"
        if (( ahead > 0 )); then status_text+=" ↑${ahead}"; fi
        if (( behind > 0 )); then status_text+=" ↓${behind}"; fi
      fi
    fi

    lines+="$shortbr\t$dir\t$status_text\n"
  done

  if (( use_fzf )) && [[ -z $FZF_MISSING ]]; then
    local out
    out="$(printf "%s" "$lines" \
      | fzf --height=${WT_FZF_HEIGHT:-40%} --reverse ${WT_FZF_OPTS:-} \
            --prompt="📋 Worktrees: " \
            --with-nth=1,2 --delimiter='\t' \
            --preview 'd=$(printf "%s" {} | awk -F"\t" "{print $2}"); if [ -d "$d" ]; then cd "$d" && git status -sb --untracked-files=all; echo; git log --oneline -n 20 --decorate --graph --color=always; fi' \
            --preview-window=right,60%)" || { echo "❌ No selection"; return 1; }
    local sel_branch sel_dir line
    line="$(printf "%s\n" "$out" | tail -n 1)"
    sel_branch="$(printf "%s\n" "$line" | awk -F"\t" '{print $1}')"
    sel_dir="$(printf "%s\n" "$line" | awk -F"\t" '{print $2}')"
    if (( do_open )); then
      # Detect editor if not specified
      if [[ -z "$open_app" ]]; then
        open_app="$(wt_get_editor 2>/dev/null)" || true
      fi
      
      if [[ -z "$open_app" ]]; then
        echo "ℹ️  Worktree is at: $sel_dir"
      else
        echo "🚀  Opening in ${open_app}…"
      fi
      [[ -n ${TEST_TMP:-} ]] && {
        {
          echo "sel_dir=$sel_dir"; echo "open_app=$open_app";
          echo "which open: $(command -v open || true)";
          echo "which xdg-open: $(command -v xdg-open || true)";
        } >> "${TEST_TMP}/wtls_dbg.txt" 2>/dev/null || true
      }
      # Test hook: record selection path for verification
      [[ -n ${TEST_TMP:-} ]] && { printf "%s\n" "$sel_dir" >> "${TEST_TMP}/open_calls.txt" 2>/dev/null || true; }
      if [[ -n ${WT_PREFER_XDG_OPEN:-} ]] && command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$sel_dir" >/dev/null 2>&1 || true
      elif command -v open >/dev/null 2>&1; then
        open -a "$open_app" "$sel_dir" >/dev/null 2>&1 || true
      elif typeset -f wt_open_in_android_studio >/dev/null 2>&1; then
        wt_open_in_android_studio "$sel_dir" "$open_app"
      elif command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$sel_dir" >/dev/null 2>&1 || true
      fi
      echo "📂  If no window appears, open it manually via File → Open… → $sel_dir"
    else
      echo "$sel_dir"
    fi
  else
    # Print tabular list
    printf "%s\n" "$lines" | awk -F"\t" '{printf "%-40s  %-60s  %s\n", $1, $2, $3}'
  fi
}


